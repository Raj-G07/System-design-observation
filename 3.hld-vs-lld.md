# ðŸ§© High-Level Design (HLD) vs Low-Level Design (LLD)

System Design can be divided into two major stages â€” **High-Level Design (HLD)** and **Low-Level Design (LLD)**.  
Both are essential parts of building scalable, maintainable software systems, but they serve **different purposes** and operate at **different levels of abstraction**.

---

## ðŸ—ï¸ 1. Overview

| Aspect | **High-Level Design (HLD)** | **Low-Level Design (LLD)** |
|:--------|:----------------------------|:----------------------------|
| **Definition** | The blueprint of the entire system â€” shows how components interact at a macro level. | The detailed plan of how each component or module will be implemented. |
| **Focus** | Architecture and relationships between major system modules. | Internal logic and class-level design within individual modules. |
| **Audience** | Architects, senior developers, tech leads. | Developers and engineers implementing the code. |
| **Abstraction Level** | High (conceptual, system-wide view). | Low (implementation details, code structure). |
| **Goal** | To define *what* the system will do and *how major components connect*. | To define *how* each component will achieve its function. |

---

## ðŸ§  2. Purpose

### **HLD**
- Define system architecture and technology choices.
- Identify components, databases, APIs, and third-party integrations.
- Establish communication between modules (e.g., REST, gRPC, message queues).
- Focus on scalability, reliability, and high-level data flow.

### **LLD**
- Design classes, interfaces, methods, and interactions.
- Define database schema and object relationships.
- Specify algorithms, design patterns, and class diagrams.
- Focus on code-level consistency and maintainability.

---

## âš™ï¸ 3. Example â€” Designing a Ride-Sharing App (e.g., Uber)

| Step | **High-Level Design (HLD)** | **Low-Level Design (LLD)** |
|:-----|:-----------------------------|:----------------------------|
| **Architecture** | Client â†’ API Gateway â†’ Ride Service â†’ Payment Service â†’ Notification Service | Detailed classes for `Ride`, `Driver`, `Rider`, `Payment`, `Notification` |
| **Data Flow** | Rider sends ride request â†’ System finds nearby driver â†’ Driver accepts â†’ Payment processed â†’ Notification sent | `RideMatchingService` implements `findNearestDriver()` using Haversine formula; `PaymentService` handles payment via strategy pattern |
| **Database Choice** | Use PostgreSQL for structured data, Redis for caching active rides | Define table schema for `rides`, `drivers`, `riders`, and `transactions` |
| **APIs** | `/createRide`, `/acceptRide`, `/makePayment` | Method-level design: `RideService.createRide(riderId, location)` |
| **Tools/Technologies** | Microservices, Load Balancer, Kafka, Redis | Design Patterns: Singleton, Factory, Observer |

---

## ðŸ§© 4. Design Artifacts

| Artifact Type | **HLD** | **LLD** |
|:----------------|:------------|:------------|
| Diagram Type | System architecture diagrams, component diagrams, data flow diagrams (DFDs) | Class diagrams, sequence diagrams, ER diagrams |
| Output Format | High-level document for technical alignment | Developer reference document or UML diagrams |
| Example Tool | Draw.io, Lucidchart, Whimsical | PlantUML, Visual Paradigm, Mermaid |

---

## ðŸš€ 5. When Each Is Used

| Phase | **HLD** | **LLD** |
|:------|:-----------|:-----------|
| **System Planning** | Used early in the design phase to validate architecture decisions. | Used later, after HLD is finalized, before implementation. |
| **Scalability Discussions** | Involves decisions like load balancing, partitioning, caching. | Focuses on performance optimization at the code and database level. |
| **Review Focus** | Reviewed by architects and tech leads. | Reviewed by developers and peers for code-level accuracy. |

---

## ðŸ§  6. Analogy

> Think of **HLD** as the **architectâ€™s blueprint** for a building â€” showing floors, rooms, and structure.  
>  
> Think of **LLD** as the **engineerâ€™s detailed plan** â€” specifying materials, wiring, and plumbing.

---

## ðŸ“š 7. Summary Table

| Feature | **High-Level Design (HLD)** | **Low-Level Design (LLD)** |
|:----------|:----------------------------|:----------------------------|
| Abstraction | System-level | Component-level |
| Focus | Architecture & communication between modules | Class structure & internal logic |
| Output | System architecture document | Detailed design document |
| Tools | Draw.io, Lucidchart | UML, PlantUML, Mermaid |
| Reviewers | Architects / Tech Leads | Developers / Reviewers |
| Concerned With | Scalability, availability, integration | Code maintainability, extensibility |
| Deliverable | Overall architecture | Class diagrams, sequence diagrams, pseudocode |
| Example Question | â€œDesign WhatsApp system.â€ | â€œDesign the class structure for chat messages.â€ |

---

## ðŸ 8. Final Thought

Both **HLD** and **LLD** are essential for complete system design:
- HLD gives the *â€œbig pictureâ€* â€” how the system works as a whole.
- LLD gives the *â€œsmall pictureâ€* â€” how each piece fits and functions internally.

> **HLD = Architecture.**  
> **LLD = Implementation.**  
>  
> Together, they form the backbone of robust software systems.
