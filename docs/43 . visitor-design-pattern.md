# üß≠ Visitor Design Pattern

## üìò Definition
The **Visitor Design Pattern** is a **behavioral pattern** that lets you **add new operations** to existing object structures **without modifying their classes**.  
It achieves this by **separating algorithms (visitors)** from the objects on which they operate.

---

## üéØ Intent
!!! tip ""
    To represent an operation to be performed on elements of an object structure.  
    The **Visitor** lets you define a new operation **without changing the classes** of the elements on which it operates.

---

## üí° Real-World Analogy
Think of a **tax auditor visiting different businesses**.  
Each business (element) accepts the auditor (visitor), and the auditor performs a specific action based on the type of business (restaurant, factory, etc.).  
The businesses don‚Äôt need to know how auditing works ‚Äî they just ‚Äúaccept‚Äù the visitor.

---

## ‚öôÔ∏è Key Participants

!!! details ""
    | Participant | Responsibility |
    |--------------|----------------|
    | **Visitor (Interface)** | Declares operations for each element type. |
    | **ConcreteVisitor** | Implements the operations defined in Visitor. |
    | **Element (Interface)** | Declares an `accept(Visitor&)` method. |
    | **ConcreteElement** | Implements `accept()` to call the visitor‚Äôs method. |
    | **ObjectStructure** | Holds a collection of elements to be visited. |

---

## üìä UML Diagram
!!! note ""
    ```mermaid
    classDiagram
        class Visitor {
            <<interface>>
            + visitConcreteElementA(a: ConcreteElementA)
            + visitConcreteElementB(b: ConcreteElementB)
        }
    
        class ConcreteVisitor {
            + visitConcreteElementA(a: ConcreteElementA)
            + visitConcreteElementB(b: ConcreteElementB)
        }
    
        class Element {
            <<interface>>
            + accept(visitor: Visitor)
        }
    
        class ConcreteElementA {
            + accept(visitor: Visitor)
            + operationA()
        }
    
        class ConcreteElementB {
            + accept(visitor: Visitor)
            + operationB()
        }
    
        Visitor <|.. ConcreteVisitor
        Element <|.. ConcreteElementA
        Element <|.. ConcreteElementB
        ConcreteElementA --> Visitor
        ConcreteElementB --> Visitor
    ```

---

## üíª C++ Implementation
```cpp title="visitor-design.cpp" linenums="1"
#include <iostream>
#include <vector>
#include <memory>
using namespace std;

// Forward declarations
class ConcreteElementA;
class ConcreteElementB;

// Visitor Interface
class Visitor {
public:
    virtual void visit(ConcreteElementA* element) = 0;
    virtual void visit(ConcreteElementB* element) = 0;
    virtual ~Visitor() = default;
};

// Element Interface
class Element {
public:
    virtual void accept(Visitor* visitor) = 0;
    virtual ~Element() = default;
};

// Concrete Elements
class ConcreteElementA : public Element {
public:
    void accept(Visitor* visitor) override {
        visitor->visit(this);
    }
    void operationA() const {
        cout << "ConcreteElementA operation executed.\n";
    }
};

class ConcreteElementB : public Element {
public:
    void accept(Visitor* visitor) override {
        visitor->visit(this);
    }
    void operationB() const {
        cout << "ConcreteElementB operation executed.\n";
    }
};

// Concrete Visitor 1
class ConcreteVisitor1 : public Visitor {
public:
    void visit(ConcreteElementA* element) override {
        cout << "ConcreteVisitor1: Visiting ElementA ‚Üí ";
        element->operationA();
    }
    void visit(ConcreteElementB* element) override {
        cout << "ConcreteVisitor1: Visiting ElementB ‚Üí ";
        element->operationB();
    }
};

// Concrete Visitor 2
class ConcreteVisitor2 : public Visitor {
public:
    void visit(ConcreteElementA* element) override {
        cout << "ConcreteVisitor2: Performing analysis on ElementA.\n";
    }
    void visit(ConcreteElementB* element) override {
        cout << "ConcreteVisitor2: Logging data for ElementB.\n";
    }
};

// Object Structure
class ObjectStructure {
    vector<shared_ptr<Element>> elements;
public:
    void addElement(shared_ptr<Element> e) { elements.push_back(e); }

    void accept(Visitor* visitor) {
        for (auto& e : elements)
            e->accept(visitor);
    }
};

// Client Code
int main() {
    ObjectStructure structure;
    structure.addElement(make_shared<ConcreteElementA>());
    structure.addElement(make_shared<ConcreteElementB>());

    ConcreteVisitor1 visitor1;
    ConcreteVisitor2 visitor2;

    cout << "=== Using ConcreteVisitor1 ===\n";
    structure.accept(&visitor1);

    cout << "\n=== Using ConcreteVisitor2 ===\n";
    structure.accept(&visitor2);

    return 0;
}
```

---

## üß† Output
``` linenums="1"
=== Using ConcreteVisitor1 ===
ConcreteVisitor1: Visiting ElementA ‚Üí ConcreteElementA operation executed.
ConcreteVisitor1: Visiting ElementB ‚Üí ConcreteElementB operation executed.

=== Using ConcreteVisitor2 ===
ConcreteVisitor2: Performing analysis on ElementA.
ConcreteVisitor2: Logging data for ElementB.
```

---

## ‚úÖ Advantages
!!! success ""
- Add new operations without modifying existing classes.
- Promotes open/closed principle ‚Äî open for extension, closed for modification.
- Centralizes behavior that would otherwise be scattered.

---

## ‚ö†Ô∏è Disadvantages
!!! warning ""
- Adding a new element type requires modifying all visitors.
- Creates tight coupling between visitor and element hierarchies.

---

## üí° Use Cases

- Compilers (different visitors for syntax tree traversal).
- Object serialization, data exporting, and analysis tools.
- Document editors applying multiple actions (print, export, format).

---

## üß± System Design View

In large-scale systems:

  - The Visitor can represent rules, validators, or analytics engines operating over diverse components.
  - Commonly used in AST (Abstract Syntax Tree) traversal for interpreters and compilers.

---

## üîó References
???+ link 
     - [Refactoring Guru ‚Äì Visitor Pattern](https://refactoring.guru/design-patterns/visitor)
     - [GeeksforGeeks ‚Äì Visitor Design Pattern in C++](https://www.geeksforgeeks.org/system-design/visitor-design-pattern/)
     - [Wikipedia ‚Äì Visitor Pattern](https://en.wikipedia.org/wiki/Visitor_pattern)
