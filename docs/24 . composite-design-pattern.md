# ğŸŒ³ Composite Design Pattern

## ğŸ“˜ Overview
!!! note ""
    The **Composite Design Pattern** is a **structural pattern** that allows you to **compose objects into tree-like structures** to represent partâ€“whole hierarchies.  

    It lets clients treat **individual objects** and **compositions of objects** **uniformly**.

    > âœ… **Use Case:** When you want to treat a group of objects (like folders or UI elements) the same way as individual ones.

---

## ğŸ’¡ Real-World Analogy

Think of a **folder structure** in your computer ğŸ’»:

- A **folder** can contain **files** or other **folders**.
- Both **files** and **folders** can be opened, moved, or deleted using the same operation.

Thus, both **File** and **Folder** behave uniformly â€” this is exactly what the Composite Pattern provides.

---

## ğŸ§© UML Class Diagram
!!! info ""
    ```mermaid
    classDiagram
        class Component {
            + showDetails()*
        }
    
        class Leaf {
            + name : string
            + showDetails()
        }
    
        class Composite {
            - children : vector<Component*>
            + add(Component*)
            + remove(Component*)
            + showDetails()
        }
    
        Component <|-- Leaf
        Component <|-- Composite
    ```

---

## ğŸ’» C++ Implementation
```cpp title="composite-design.cpp" linenums="1"
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Component {
public:
    virtual void showDetails(int indent = 0) const = 0;
    virtual ~Component() = default;
};

class File : public Component {
    string name;
public:
    File(string n) : name(std::move(n)) {}
    void showDetails(int indent = 0) const override {
        cout << string(indent, ' ') << "ğŸ“„ File: " << name << endl;
    }
};

class Folder : public Component {
    string name;
    vector<Component*> children;
public:
    Folder(string n) : name(std::move(n)) {}

    void add(Component* c) { children.push_back(c); }
    void remove(Component* c) {
        children.erase(remove(children.begin(), children.end(), c), children.end());
    }

    void showDetails(int indent = 0) const override {
        cout << string(indent, ' ') << "ğŸ“ Folder: " << name << endl;
        for (const auto& child : children) {
            child->showDetails(indent + 2);
        }
    }
};

int main() {
    File file1("Resume.pdf");
    File file2("Design.docx");
    File file3("Image.png");

    Folder documents("Documents");
    Folder images("Images");
    Folder root("Root");

    documents.add(&file1);
    documents.add(&file2);
    images.add(&file3);

    root.add(&documents);
    root.add(&images);

    root.showDetails(); // Display full hierarchy
}
```

---

## ğŸ§  Output

```yaml linenums="1"
ğŸ“ Folder: Root
  ğŸ“ Folder: Documents
    ğŸ“„ File: Resume.pdf
    ğŸ“„ File: Design.docx
  ğŸ“ Folder: Images
    ğŸ“„ File: Image.png
```

---

## âš™ï¸ Key Concepts

!!! details ""
    | Role          | Responsibility                          |
    | ------------- | --------------------------------------- |
    | **Component** | Defines the interface for all objects   |
    | **Leaf**      | Represents the individual object        |
    | **Composite** | Contains and manages child components   |
    | **Client**    | Interacts with all components uniformly |

## ğŸ§° When to Use

- To represent part-whole hierarchies
- When you want uniform treatment for single and grouped objects
- When tree-like structures (e.g., UI components, file systems) are needed

## âœ… Advantages
!!! success ""
    - Simplifies client code (no need to distinguish between single or composite objects)
    - Makes the system extensible â€” easy to add new types of components
    - Promotes recursion and reusability

## âš ï¸ Drawbacks
!!! warning ""
    - Can make design overly general
    - May be hard to restrict certain operations to specific components

## ğŸ”— References
???+ link 
     - [Refactoring Guru â€“ Composite Pattern](https://refactoring.guru/design-patterns/composite)
     - [GeeksforGeeks â€“ Composite Design Pattern](https://www.geeksforgeeks.org/java/composite-design-pattern-in-java/)
     - [SourceMaking â€“ Composite Pattern](https://sourcemaking.com/design_patterns/composite)
     