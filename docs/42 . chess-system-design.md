# â™Ÿï¸ Multiplayer Chess System Design
## Overview
!!! note ""
    The **Multiplayer Chess Platform** enables multiple users to play chess simultaneously under standard rules, with features like score-based matchmaking, in-game chat, and session handling when users quit or finish a game.

    The system is designed to be **scalable**, **extensible**, and **real-time** for competitive gameplay and future enhancements.

---

## Functional Requirements
**ðŸŽ® Core Features**

1. Multiple Concurrent Matches

  - Multiple users can play chess simultaneously in different sessions.
  - Each match runs independently, allowing scalability.

2. Score-Based Matchmaking

  - Users are paired based on similar skill or rating (ELO-based or score-based algorithm).
  - The matchmaking system dynamically searches for opponents within a score tolerance range.

3. Standard Chess Rules (Scalable)

  - The game engine enforces standard chess rules such as piece movement, captures, and turns.
  - The system design allows easy extension to add features like castling, pawn promotion, timers, and new variants (e.g., blitz chess, 3-check).

4. In-Match Chat System

  - Players can send and receive messages during a match.
  - Chat is isolated to each game and uses a thread-safe message queue.
  - Chat logs can be optionally stored for replay or moderation.

5. User Quit Handling

  - Players can quit a match at any time.
  - The session manager detects early quits and declares the other player as the winner or records the match as incomplete.
  - Resources and match states are cleaned up gracefully.

---

## System Components
**1. User Management**

  - Handles user registration, login, and profile management.
  - Tracks player ID, username, and rating.
  - Maintains a list of active users and their session states.
  - Supports concurrent user sessions safely.

**Responsibilities:**

 - Register new users.
 - Retrieve player information.
 - Manage user activity status.

**2. Matchmaking System**

 - Implements a score-based pairing algorithm that matches players with similar ELO or performance scores.
 - Supports dynamic queues for users waiting for matches.
 - Automatically initiates matches once suitable pairs are found.

**Responsibilities:**

 - Maintain a queue of waiting players.
 - Pair players within a score range (e.g., Â±200).
 - Initiate new game sessions.
 - Clean up finished or disconnected matches.

**3. Game Engine**

 - Core logic for chess gameplay.
 - Responsible for move validation, piece interactions, and maintaining the board state.

  **Responsibilities:**

  - Implement movement rules for all pieces.
  - Check for valid moves and enforce turns.
  - Handle pawn promotion, captures, and king safety.
  - Detect match end conditions (checkmate, stalemate, or resignation).

  **Extensibility:**

  - Support for timers, undo moves, or AI-based analysis.
  - Add new chess variants (e.g., 3-player chess or timed modes).

**4. Chat System**

 - Enables real-time communication between players during a match.
 - Each match maintains its own message queue.
 - Thread-safe design ensures consistency under concurrent message sends.

  **Responsibilities:**

  - Send and receive messages.
  - Maintain per-match chat history.
  - Optionally integrate moderation and filtering.

**5. Session Management**

 - Oversees match lifecycle, including start, progress, and termination.

 - Monitors player activity (e.g., quit, timeout, or disconnect).

 - Ensures resources are released and results are saved properly.

   **Responsibilities:**

   - Detect if a player quits mid-game.
   - End match gracefully and update user stats.
   - Save match results and logs.
   - Manage ongoing match threads and cleanup.

---

## System Flow

**1. User Registration/Login**
  â†’ User connects to the platform and logs in.
  â†’ User is added to the pool of active players.

**2. Matchmaking Process**
  â†’ User requests a match.
  â†’ The matchmaking system finds an opponent within a score range.
  â†’ A new match session is created.

**3. Game Execution**
  â†’ Game Engine initializes a new board.
  â†’ Players alternate turns making valid moves.
  â†’ Real-time updates are broadcast to both players.

**4. In-Match Chat**
  â†’ Players exchange messages through the chat system.
  â†’ Messages are processed asynchronously.

**5. Session Termination**
  â†’ Match ends via checkmate, draw, timeout, or user quit.
  â†’ Results and chat history are logged.
  â†’ Players can re-enter the matchmaking pool.

---

## Scalability & Extensibility

**Scalability:**
  - Designed to support hundreds of concurrent matches using independent threads or asynchronous I/O (in production servers, this would use event-driven architecture).

**Extensibility:**
  - Easy to integrate:
  - New matchmaking logic (league, tournament).
  - AI opponents (Stockfish or custom engine).
  - New UIs or APIs via REST/WebSocket.

**Resilience:**
  - Handles early quits, dropped connections, and concurrency safely.

---

## UML Diagram
!!! note ""
    ```mermaid
    graph TD
        %% Core System
        A[Chess Platform] --> B[User Management]
        A --> C[Matchmaking System]
        A --> D[Game Engine]
        A --> E[Chat System]
        A --> F[Session Management]
    
        %% User Management
        B --> B1[Register / Login Users]
        B --> B2[Manage Active Users]
        B --> B3[Handle Multiple Concurrent Users]
    
        %% Matchmaking
        C --> C1[Score-Based Matchmaking Algorithm]
        C --> C2[Pair Users with Similar Skill Level]
        C --> C3[Initiate Match Session]
    
        %% Game Engine
        D --> D1[Implements Standard Chess Rules]
        D --> D2[Supports Scalable Rule Extensions]
        D --> D3[Handles Move Validation]
        D --> D4[Updates Game State in Real-Time]
    
        %% Chat System
        E --> E1[Send/Receive Messages During Match]
        E --> E2[Maintain Chat History per Match]
    
        %% Session Management
        F --> F1[Handle User Quit / Forfeit]
        F --> F2[Save Game Results and Scores]
        F --> F3[End Match Gracefully]
    
        %% Interactions
        B3 --> C
        C3 --> D
        C3 --> E
        C3 --> F
    ```

---

## C++ implementation
```cpp title="chess.cpp" linenums="1"
// multiplayer_chess_sim.cpp
// Single-file simulation of a multiplayer chess system with matchmaking, chat, simple game engine, and session management.
// Compile: g++ -std=c++17 -pthread multiplayer_chess_sim.cpp -o chess_sim
// Run: ./chess_sim

#include <bits/stdc++.h>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
using namespace std;

/* -----------------------------
   Utility / Types
   ----------------------------- */
using UserId = int;
using MatchId = int;
enum class Piece { EMPTY, P, R, N, B, Q, K };
enum class Color { NONE, WHITE, BLACK };

struct PlayerInfo {
    UserId id;
    string name;
    int score; // rating
};

/* -----------------------------
   Thread-safe Queue for Chat
   ----------------------------- */
template<typename T>
class TSQueue {
    mutex m;
    condition_variable cv;
    deque<T> q;
public:
    void push(const T& v) {
        {
            lock_guard<mutex> lk(m);
            q.push_back(v);
        }
        cv.notify_one();
    }
    // wait and pop one
    T wait_pop() {
        unique_lock<mutex> lk(m);
        cv.wait(lk, [&]{ return !q.empty(); });
        T v = q.front(); q.pop_front();
        return v;
    }
    bool try_pop(T &out) {
        lock_guard<mutex> lk(m);
        if(q.empty()) return false;
        out = q.front(); q.pop_front();
        return true;
    }
    bool empty() {
        lock_guard<mutex> lk(m);
        return q.empty();
    }
};

/* -----------------------------
   User Management (simple)
   ----------------------------- */
class UserManager {
    mutex m;
    UserId nextId = 1;
    unordered_map<UserId, PlayerInfo> users;
public:
    UserId registerUser(const string &name, int score) {
        lock_guard<mutex> lk(m);
        UserId id = nextId++;
        users[id] = PlayerInfo{id, name, score};
        return id;
    }
    PlayerInfo getUser(UserId id) {
        lock_guard<mutex> lk(m);
        return users.at(id);
    }
    vector<PlayerInfo> listActive() {
        lock_guard<mutex> lk(m);
        vector<PlayerInfo> res;
        for (auto &p : users) res.push_back(p.second);
        return res;
    }
};

/* -----------------------------
   Simple Chess Board & Engine
   - 8x8 board
   - Basic rules: piece movement checks (no castling/en-passant), simple checkmate detection is NOT complete.
   - For demonstration only.
   ----------------------------- */

struct Cell {
    Piece piece;
    Color color;
    Cell(): piece(Piece::EMPTY), color(Color::NONE) {}
    Cell(Piece p, Color c): piece(p), color(c) {}
    bool empty() const { return piece == Piece::EMPTY; }
};

struct Pos {
    int r, c;
    Pos(int rr=0,int cc=0): r(rr), c(cc) {}
    bool inBounds() const { return r>=0 && r<8 && c>=0 && c<8; }
    bool operator==(const Pos& o) const { return r==o.r && c==o.c; }
};

string posToStr(const Pos& p) {
    string s;
    s += char('a' + p.c);
    s += char('1' + (7 - p.r)); // row 0 is rank 8
    return s;
}

class GameEngine {
    array<array<Cell,8>,8> board;
    Color turn;
    atomic<bool> finished;
    mutex m; // protect board + state

public:
    GameEngine() { reset(); }

    void reset() {
        lock_guard<mutex> lk(m);
        // Clear
        for (int i=0;i<8;i++) for (int j=0;j<8;j++) board[i][j]=Cell();
        // Setup pawns
        for (int j=0;j<8;j++) {
            board[1][j] = Cell(Piece::P, Color::BLACK);
            board[6][j] = Cell(Piece::P, Color::WHITE);
        }
        // Rooks
        board[0][0]=board[0][7]=Cell(Piece::R, Color::BLACK);
        board[7][0]=board[7][7]=Cell(Piece::R, Color::WHITE);
        // Knights
        board[0][1]=board[0][6]=Cell(Piece::N, Color::BLACK);
        board[7][1]=board[7][6]=Cell(Piece::N, Color::WHITE);
        // Bishops
        board[0][2]=board[0][5]=Cell(Piece::B, Color::BLACK);
        board[7][2]=board[7][5]=Cell(Piece::B, Color::WHITE);
        // Queens
        board[0][3]=Cell(Piece::Q, Color::BLACK);
        board[7][3]=Cell(Piece::Q, Color::WHITE);
        // Kings
        board[0][4]=Cell(Piece::K, Color::BLACK);
        board[7][4]=Cell(Piece::K, Color::WHITE);

        turn = Color::WHITE;
        finished = false;
    }

    // Very simple move parser from "e2e4" format
    bool parsePos(const string &s, Pos &out) {
        if (s.size() != 2) return false;
        char file = s[0];
        char rank = s[1];
        if (file < 'a' || file > 'h') return false;
        if (rank < '1' || rank > '8') return false;
        int c = file - 'a';
        int r = 7 - (rank - '1');
        out = Pos(r,c);
        return true;
    }

    // Basic move validation (not exhaustive)
    bool validMove(const Pos &from, const Pos &to, Color player) {
        if (!from.inBounds() || !to.inBounds()) return false;
        Cell src = board[from.r][from.c];
        Cell dst = board[to.r][to.c];
        if (src.empty()) return false;
        if (src.color != player) return false;
        if (!dst.empty() && dst.color == player) return false;

        int dr = to.r - from.r;
        int dc = to.c - from.c;
        Piece p = src.piece;
        switch (p) {
            case Piece::P: {
                int dir = (src.color==Color::WHITE) ? -1 : 1;
                // single step
                if (dc == 0 && dr == dir && dst.empty()) return true;
                // initial double step
                if (dc == 0 && dr == 2*dir) {
                    int startRow = (src.color==Color::WHITE) ? 6 : 1;
                    if (from.r == startRow && dst.empty() && board[from.r+dir][from.c].empty()) return true;
                }
                // capture
                if (abs(dc)==1 && dr==dir && !dst.empty() && dst.color != src.color) return true;
                return false;
            }
            case Piece::R: {
                if (dr!=0 && dc!=0) return false;
                int rr = (dr==0) ? 0 : (dr>0?1:-1);
                int cc = (dc==0) ? 0 : (dc>0?1:-1);
                int steps = max(abs(dr),abs(dc));
                for (int s=1;s<steps;s++) if (!board[from.r + rr*s][from.c + cc*s].empty()) return false;
                return true;
            }
            case Piece::B: {
                if (abs(dr) != abs(dc)) return false;
                int rr = (dr>0?1:-1), cc=(dc>0?1:-1);
                for (int s=1;s<abs(dr);s++) if (!board[from.r + rr*s][from.c + cc*s].empty()) return false;
                return true;
            }
            case Piece::Q: {
                if (dr==0 || dc==0) {
                    int rr = (dr==0)?0:(dr>0?1:-1);
                    int cc = (dc==0)?0:(dc>0?1:-1);
                    int steps = max(abs(dr),abs(dc));
                    for (int s=1;s<steps;s++) if (!board[from.r + rr*s][from.c + cc*s].empty()) return false;
                    return true;
                } else if (abs(dr)==abs(dc)) {
                    int rr=(dr>0?1:-1), cc=(dc>0?1:-1);
                    for (int s=1;s<abs(dr);s++) if (!board[from.r + rr*s][from.c + cc*s].empty()) return false;
                    return true;
                } else return false;
            }
            case Piece::N: {
                if ((abs(dr)==2 && abs(dc)==1) || (abs(dr)==1 && abs(dc)==2)) return true;
                return false;
            }
            case Piece::K: {
                if (max(abs(dr),abs(dc))==1) return true;
                return false;
            }
            default: return false;
        }
    }

    // Move piece, return true if moved
    bool makeMove(const string &fromStr, const string &toStr, Color player, string &err) {
        lock_guard<mutex> lk(m);
        if (finished) { err = "Game already finished"; return false; }
        Pos from, to;
        if (!parsePos(fromStr, from) || !parsePos(toStr, to)) { err = "Invalid coordinates"; return false; }
        if (!validMove(from, to, player)) { err = "Illegal move"; return false; }
        // perform
        Cell src = board[from.r][from.c];
        Cell dst = board[to.r][to.c];
        board[to.r][to.c] = src;
        board[from.r][from.c] = Cell();
        // pawn promotion simplification: promote to queen if reaches last rank
        if (src.piece == Piece::P) {
            if ((src.color==Color::WHITE && to.r==0) || (src.color==Color::BLACK && to.r==7)) {
                board[to.r][to.c].piece = Piece::Q;
            }
        }
        // swap turn
        turn = (turn==Color::WHITE?Color::BLACK:Color::WHITE);
        return true;
    }

    // Very simple "is game over?" - here we just detect if a king is captured.
    bool checkFinished() {
        lock_guard<mutex> lk(m);
        bool whiteKing=false, blackKing=false;
        for (int i=0;i<8;i++) for (int j=0;j<8;j++) {
            if (board[i][j].piece == Piece::K) {
                if (board[i][j].color == Color::WHITE) whiteKing=true;
                if (board[i][j].color == Color::BLACK) blackKing=true;
            }
        }
        if (!whiteKing || !blackKing) {
            finished = true;
            return true;
        }
        return false;
    }

    // Return FEN-like simple board print
    string boardStr() {
        lock_guard<mutex> lk(m);
        string s;
        for (int i=0;i<8;i++) {
            for (int j=0;j<8;j++) {
                Cell c = board[i][j];
                char ch='.';
                if (!c.empty()) {
                    switch (c.piece) {
                        case Piece::P: ch='p'; break;
                        case Piece::R: ch='r'; break;
                        case Piece::N: ch='n'; break;
                        case Piece::B: ch='b'; break;
                        case Piece::Q: ch='q'; break;
                        case Piece::K: ch='k'; break;
                        default: ch='?';
                    }
                    if (c.color==Color::WHITE) ch = toupper(ch);
                }
                s += ch; s += ' ';
            }
            s += '\n';
        }
        return s;
    }

    Color currentTurn() {
        lock_guard<mutex> lk(m);
        return turn;
    }

    void forceFinish() {
        finished = true;
    }
};

/* -----------------------------
   Chat System (per-match)
   ----------------------------- */
struct ChatMessage {
    UserId from;
    string text;
    chrono::system_clock::time_point ts;
};

class ChatSystem {
    TSQueue<ChatMessage> q;
public:
    void send(UserId from, const string &text) {
        q.push(ChatMessage{from, text, chrono::system_clock::now()});
    }
    // blocking receive (simulate pushing to client)
    ChatMessage receiveBlocking() {
        return q.wait_pop();
    }
    // try non-blocking
    bool tryReceive(ChatMessage &out) {
        return q.try_pop(out);
    }
};

/* -----------------------------
   Match / Session Management
   ----------------------------- */

class Match {
    MatchId id;
    PlayerInfo whitePlayer;
    PlayerInfo blackPlayer;
    GameEngine game;
    ChatSystem chat;
    thread matchThread;
    atomic<bool> running;
    mutex outm; // printing
    atomic<bool> whiteQuit, blackQuit;

public:
    Match(MatchId mid, PlayerInfo p1, PlayerInfo p2)
    : id(mid), whitePlayer(p1), blackPlayer(p2), running(false), whiteQuit(false), blackQuit(false)
    {
        // We assign higher rated player to white arbitrarily
        if (whitePlayer.score < blackPlayer.score) swap(whitePlayer, blackPlayer);
    }

    void start() {
        running = true;
        matchThread = thread(&Match::run, this);
    }

    void joinThread() {
        if (matchThread.joinable()) matchThread.join();
    }

    void run() {
        {
            lock_guard<mutex> lk(outm);
            cout << "[Match " << id << "] Started: " << whitePlayer.name << " (white) vs " << blackPlayer.name << " (black)\n";
        }
        game.reset();
        // Simulated play loop: to show functioning, we will alternate "random moves" for a few turns or accept quittings
        // In a real system we would accept moves from networked players.
        int turnCount = 0;
        while (running) {
            if (whiteQuit || blackQuit) {
                lock_guard<mutex> lk(outm);
                cout << "[Match " << id << "] A player quit. ";
                if (whiteQuit) cout << whitePlayer.name << " quit. ";
                if (blackQuit) cout << blackPlayer.name << " quit. ";
                cout << "Terminating match.\n";
                game.forceFinish();
                break;
            }
            // For demo: process chat messages if any
            ChatMessage cm;
            while (chat.tryReceive(cm)) {
                lock_guard<mutex> lk(outm);
                string who = (cm.from == whitePlayer.id) ? whitePlayer.name : (cm.from == blackPlayer.id ? blackPlayer.name : "unknown");
                cout << "[Match " << id << "][CHAT] " << who << ": " << cm.text << "\n";
            }

            // Check finished
            if (game.checkFinished()) {
                lock_guard<mutex> lk(outm);
                cout << "[Match " << id << "] Game finished by capture of king.\n";
                break;
            }

            // For simulation, make a dummy legal move for current player from a list of candidate moves.
            Color cur = game.currentTurn();
            PlayerInfo curPlayer = (cur==Color::WHITE) ? whitePlayer : blackPlayer;
            // simulate quitting: if random small chance player quits
            if ((rand()%1000) < 5) { // tiny chance
                if (cur==Color::WHITE) whiteQuit = true;
                else blackQuit = true;
                continue;
            }

            // We will search simple moves: move any pawn forward if possible, else try small moves
            bool moved = false;
            // trying to find any legal move brute-force
            for (int r=0;r<8 && !moved;r++) for (int c=0;c<8 && !moved;c++) {
                Pos from(r,c);
                // build coordinate strings
                // attempt to move to all possible squares
                for (int rr=0;rr<8 && !moved;rr++) for (int cc=0;cc<8 && !moved;cc++) {
                    Pos to(rr,cc);
                    // skip same
                    if (from==to) continue;
                    // prepare strings
                    string fromS = posToStr(from);
                    string toS = posToStr(to);
                    string err;
                    if (game.makeMove(fromS, toS, cur, err)) {
                        // succeeded
                        lock_guard<mutex> lk(outm);
                        cout << "[Match " << id << "] " << curPlayer.name << " (" << (cur==Color::WHITE?"W":"B") << ") moved " << fromS << " -> " << toS << "\n";
                        moved = true;
                        break;
                    }
                }
            }
            // if no move found (stalemate or blocked) â€” finish
            if (!moved) {
                lock_guard<mutex> lk(outm);
                cout << "[Match " << id << "] No legal move found for current player. Ending match.\n";
                break;
            }

            turnCount++;
            if (turnCount > 200) { // limit for demo
                lock_guard<mutex> lk(outm);
                cout << "[Match " << id << "] Move limit reached, ending match as draw.\n";
                break;
            }

            // small sleep to let output be readable
            this_thread::sleep_for(chrono::milliseconds(50));
        } // end while

        {
            lock_guard<mutex> lk(outm);
            cout << "[Match " << id << "] cleaning up\n";
        }
        running = false;
    }

    void sendChat(UserId from, const string &text) {
        chat.send(from, text);
    }

    void playerQuit(UserId uid) {
        if (uid == whitePlayer.id) whiteQuit = true;
        else if (uid == blackPlayer.id) blackQuit = true;
    }

    bool isRunning() const { return running; }
};

/* -----------------------------
   MatchMaker
   - Simple queue-based matchmaking by score proximity
   ----------------------------- */

class MatchMaker {
    mutex m;
    MatchId nextMatchId = 1;
    vector<shared_ptr<Match>> matches;
    deque<PlayerInfo> waiting;
    int scoreTolerance = 200; // +- rating window
public:
    // add waiting player and attempt to create matches
    void enterQueue(const PlayerInfo &p) {
        lock_guard<mutex> lk(m);
        waiting.push_back(p);
        tryMakeMatches();
    }

    // naive matching: scan waiting for pairs within tolerance
    void tryMakeMatches() {
        for (size_t i=0;i<waiting.size();++i) {
            for (size_t j=i+1;j<waiting.size();++j) {
                if (abs(waiting[i].score - waiting[j].score) <= scoreTolerance) {
                    // create match
                    PlayerInfo a = waiting[i];
                    PlayerInfo b = waiting[j];
                    // remove j then i
                    waiting.erase(waiting.begin()+j);
                    waiting.erase(waiting.begin()+i);
                    makeMatch(a,b);
                    // restart scanning
                    tryMakeMatches();
                    return;
                }
            }
        }
    }

    void makeMatch(const PlayerInfo &a, const PlayerInfo &b) {
        MatchId mid = nextMatchId++;
        auto match = make_shared<Match>(mid, a, b);
        matches.push_back(match);
        match->start();
    }

    vector<shared_ptr<Match>> currentMatches() {
        lock_guard<mutex> lk(m);
        return matches;
    }

    // for demo: cleanup finished matches
    void cleanup() {
        lock_guard<mutex> lk(m);
        vector<shared_ptr<Match>> active;
        for (auto &mm : matches) {
            if (mm->isRunning()) active.push_back(mm);
            else mm->joinThread();
        }
        matches.swap(active);
    }
};

/* -----------------------------
   Demo / Main simulation
   ----------------------------- */

int main() {
    srand((unsigned)chrono::system_clock::now().time_since_epoch().count());
    UserManager um;
    MatchMaker mm;

    // Create sample users
    UserId u1 = um.registerUser("Alice", 1500);
    UserId u2 = um.registerUser("Bob", 1520);
    UserId u3 = um.registerUser("Charlie", 1300);
    UserId u4 = um.registerUser("Diana", 1490);
    UserId u5 = um.registerUser("Eve", 1700);

    // Enter matchmaking queue
    mm.enterQueue(um.getUser(u1));
    mm.enterQueue(um.getUser(u2));
    mm.enterQueue(um.getUser(u3));
    mm.enterQueue(um.getUser(u4));
    mm.enterQueue(um.getUser(u5));

    // Let matches begin
    this_thread::sleep_for(chrono::milliseconds(200));

    // Find match threads and send some chat messages / quit events
    auto active = mm.currentMatches();
    if (!active.empty()) {
        auto m0 = active[0];
        // send a chat from white (we don't know exact assignment here but demo call)
        m0->sendChat(u1, "gl hf!");
        m0->sendChat(u2, "good luck!");
        // simulate a quit after some time
        this_thread::sleep_for(chrono::milliseconds(300));
        // For demonstration, make one player quit
        m0->playerQuit(u2);
    }

    // Let system run a bit
    for (int i=0;i<50;i++) {
        mm.cleanup();
        this_thread::sleep_for(chrono::milliseconds(200));
    }

    // Wait for remaining matches to finish
    auto all = mm.currentMatches();
    for (auto &m : all) {
        m->joinThread();
    }

    cout << "Simulation done.\n";
    return 0;
}
```

---

## Future Enhancements

- Implement advanced chess rules (checkmate detection, castling, en passant).
- Add persistent database (MongoDB or PostgreSQL) for player stats and match history.
- Introduce live spectators and game replays.
- Integrate authentication systems (OAuth, JWT).
- Add AI opponents and difficulty levels.
- Enable mobile and web interfaces.

---

## Summary

!!! details ""
    | Component           | Responsibility                | Key Features                |
    | ------------------- | ----------------------------- | --------------------------- |
    | **User Manager**    | Handle user creation & login  | Multiple users at once      |
    | **Matchmaker**      | Pair players by rating        | Fair & fast matchmaking     |
    | **Game Engine**     | Chess logic and board updates | Scalable and rule-compliant |
    | **Chat System**     | Real-time communication       | Thread-safe messaging       |
    | **Session Manager** | Lifecycle control & cleanup   | Handles quits and results   |
