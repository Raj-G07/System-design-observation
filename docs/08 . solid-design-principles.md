# üö´ Problems Without Design Principles & ‚úÖ SOLID Principles

## üí• What Happens Without Design Principles

When a software system is developed **without following proper design principles**, it often leads to:

### 1. **Tight Coupling**
- Classes and modules become highly dependent on each other.  
- A small change in one class breaks multiple other components.  
- Difficult to maintain or extend functionality.

### 2. **Low Cohesion**
- A single class handles multiple unrelated responsibilities.  
- Code becomes confusing, harder to debug, and violates **Single Responsibility**.

### 3. **Poor Scalability**
- Difficult to adapt to new requirements.  
- System fails to handle growth in users, data, or features.

### 4. **Code Duplication**
- Lack of modularity leads to repeated logic across files.  
- Increases maintenance effort and chances of bugs.

### 5. **Difficult Testing**
- Since modules depend on each other, unit testing becomes painful.  
- Mocking or isolating functionalities is nearly impossible.

### 6. **Inflexible Architecture**
- New requirements break existing code.  
- Developers are scared to make changes due to regression risks.

---

## üß± Introduction to SOLID Principles

To avoid the above problems, we follow **SOLID principles**, introduced by Robert C. Martin (Uncle Bob).  
They make software **flexible, maintainable, and scalable**.

---

## üß© The 5 SOLID Principles

### 1. **S ‚Äî Single Responsibility Principle (SRP)**
> A class should have **only one reason to change**.

‚úÖ Each class should handle one specific job.  
‚ùå Don‚Äôt mix responsibilities like database operations and UI logic in the same class.

**Example:**
```cpp title="srp.cpp" linenums="1"
// ‚ùå Violates SRP
class Report {
public:
    void generateReport();
    void printReport(); // Printing isn't the responsibility of Report class
};

// ‚úÖ Follows SRP
class Report {
public:
    void generateReport();
};

class ReportPrinter {
public:
    void printReport(const Report& report);
};
```
### 2. **O ‚Äî Open/Closed Principle (OCP)**
> Software entities should be open for extension but closed for modification.

‚úÖ You can add new behavior without changing existing code.

**Example:**
```cpp title="ocp.cpp" linenums="1"
// ‚úÖ Using polymorphism
class Payment {
public:
    virtual void processPayment() = 0;
};

class CreditCardPayment : public Payment {
public:
    void processPayment() override { /* ... */ }
};

class UPIPayment : public Payment {
public:
    void processPayment() override { /* ... */ }
};
```

### 3. **L ‚Äî Liskov Substitution Principle (LSP)**
> Subtypes must be substitutable for their base types.

‚úÖ If a program expects a parent class, any subclass should work without issues.

**Example:**
```cpp title="lsp.cpp" linenums="1"
class Bird {
public:
    virtual void fly() = 0;
};

class Sparrow : public Bird {
public:
    void fly() override { /* can fly */ }
};

// ‚ùå Violates LSP
class Penguin : public Bird {
public:
    void fly() override { throw "Can't fly!"; }
};
```

## 4. **I ‚Äî Interface Segregation Principle (ISP)**
> Clients should not be forced to depend on interfaces they do not use.

‚úÖ Break large interfaces into smaller, more specific ones.

**Example:**
```cpp title="isp.cpp" linenums="1"
// ‚ùå One large interface
class IWorker {
public:
    virtual void work() = 0;
    virtual void eat() = 0;
};

// ‚úÖ Split interfaces
class IWorkable {
public:
    virtual void work() = 0;
};

class IFeedable {
public:
    virtual void eat() = 0;
};
```

## 5. D ‚Äî Dependency Inversion Principle (DIP)
> Depend on abstractions, not concretions.

‚úÖ High-level modules should not depend on low-level modules.
Both should depend on abstractions (interfaces).

**Example:**
```cpp title="dip.cpp" linenums="1"
// ‚úÖ DIP Example
class IKeyboard {
public:
    virtual void input() = 0;
};

class MechanicalKeyboard : public IKeyboard {
public:
    void input() override { /* ... */ }
};

class Computer {
    IKeyboard* keyboard;
public:
    Computer(IKeyboard* k) : keyboard(k) {}
};
```

---

## üîÅ Summary Table

!!! details ""
    | Problem Without Design	| SOLID Solution |
    |:-----|:-----|
    | Tight coupling | Dependency Inversion |
    | Multiple responsibilities	| Single Responsibility |
    | Difficult extension |	Open/Closed |
    | Broken inheritance	| Liskov Substitution |
    | Large, messy interfaces|	Interface Segregation |

---

## üîó Reference

- [SOLID Principles in C++ (GeeksforGeeks)](https://www.geeksforgeeks.org/solid-principles-in-cpp/)
- [SOLID Principles Explained by Robert C. Martin](https://www.youtube.com/watch?v=TMuno5RZNeE)
- [Refactoring Guru - SOLID](https://refactoring.guru/design-patterns/solid)
