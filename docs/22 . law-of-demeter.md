# ğŸ§­ Principle of Least Knowledge (Law of Demeter)

## ğŸ“˜ Overview

The **Principle of Least Knowledge**, also known as the **Law of Demeter**, states that:
> *"An object should only talk to its immediate friends, and not to strangers."*

In other words, **each unit should have limited knowledge about other units** â€” only enough to perform its job.

This principle promotes **low coupling** and **high cohesion**, improving **maintainability**, **readability**, and **testability**.

---

## ğŸ’¡ Real-World Analogy

Imagine a customer ordering coffee â˜•:  
The customer tells the **waiter** what they want â€” not the **barista** or **coffee machine** directly.  
The waiter communicates internally to fulfill the order.

> âŒ Bad: Customer â†’ Barista â†’ CoffeeMachine  
> âœ… Good: Customer â†’ Waiter â†’ (Waiter handles the rest)

---

## âš™ï¸ Rule of Thumb

A method of an object should only call methods of:
1. Itself  
2. Its own member variables  
3. Objects passed as parameters  
4. Objects it creates  
5. Its direct components  

Anything beyond that â€” like chaining method calls â€” **violates the principle**.

---

## ğŸ§© UML Diagram

```mermaid
classDiagram
    class Customer {
        + orderCoffee()
    }
    class Waiter {
        + takeOrder()
    }
    class Barista {
        + prepareCoffee()
    }
```

---

## ğŸ’» C++ Implementation
- âŒ Without the Principle (Tight Coupling)
```cpp title="without-law-of-demeter.cpp" linenums="1"
#include <iostream>
using namespace std;

class CoffeeMachine {
public:
    void brew() { cout << "Brewing coffee...\n"; }
};

class Barista {
public:
    CoffeeMachine machine;
};

class Customer {
public:
    void orderCoffee(Barista& barista) {
        // Violates Principle of Least Knowledge
        barista.machine.brew();
    }
};

int main() {
    Barista barista;
    Customer customer;
    customer.orderCoffee(barista);
}
```

- âœ… Applying the Principle of Least Knowledge
```cpp title="with-law-of-demeter.cpp" linenums="1"
#include <iostream>
using namespace std;

class CoffeeMachine {
public:
    void brew() { cout << "Brewing coffee...\n"; }
};

class Barista {
private:
    CoffeeMachine machine;
public:
    void makeCoffee() { machine.brew(); }
};

class Customer {
public:
    void orderCoffee(Barista& barista) {
        // Follows the principle â€” only interacts with Barista
        barista.makeCoffee();
    }
};

int main() {
    Barista barista;
    Customer customer;
    customer.orderCoffee(barista);
}
```

---

## ğŸ§  Key Takeaways
| Concept    | Description                                             |
| ---------- | ------------------------------------------------------- |
| **Goal**   | Reduce coupling and hidden dependencies                 |
| **Effect** | Improves modularity and maintainability                 |
| **Avoid**  | Long method chains like `a.getB().getC().doSomething()` |
| **Follow** | â€œTalk to friends, not to strangersâ€                     |

---

## ğŸ§° When to Apply

- Large systems where modules depend on each other
- To prevent "ripple effects" when a small change in one class breaks others
- When designing APIs or service boundaries

## ğŸ”— References

- [Refactoring Guru â€“ Law of Demeter](https://refactoring.guru/design-patterns/law-of-demeter)
- [GeeksforGeeks â€“ Principle of Least Knowledge](https://www.geeksforgeeks.org/principle-of-least-knowledge-law-of-demeter/)
- [SourceMaking â€“ Law of Demeter](https://sourcemaking.com/refactoring/law-of-demeter)
