# üêç Snake and Ladder Game ‚Äì System Design
## üéØ Overview
!!! note ""
    The Snake and Ladder Game is designed to be scalable, extensible, and strategy-driven.
    It follows object-oriented principles and design patterns that make the system easy to maintain and enhance with new features.

---

## ‚öôÔ∏è Core Requirements
**Functional Requirements**

- The game follows standard Snake and Ladder rules.
- The board size should be scalable (e.g., 50x50, 100x100, etc.).
- The system should support multiple players.
- Players take turns rolling a dice and moving forward.
- If a player lands at the bottom of a ladder, they move up.
- If a player lands on the head of a snake, they move down.
- The first player to reach the final square wins.

**Non-Functional Requirements**

- The design should be easily extensible to add new features (e.g., Power-ups, Portals).
- The system should support different board setup strategies.
- The code should follow the Single Responsibility Principle (SRP).
- The system should allow customization and randomization of the game setup.

---

## üß± Key Design Principles
**1. Scalability**

- The Board class allows the board size to be changed dynamically.
- Supports any board dimension (e.g., 50, 100, 200 cells).

**2. Extensibility**

- Implemented using the Strategy Pattern to allow different ways of setting up the board.
- New setup strategies can be added without modifying existing code.

**3. Encapsulation**

- Each component (Game, Board, Player, Dice, Strategy) is isolated and manages its own data and behavior.

---

## üß© Core Components
**1. Game**

- Acts as the controller of the system.
- Manages players, board, dice, and strategy.
- Handles turn-by-turn gameplay and winner validation.

**2. Board**

- **Maintains:**

  - **size** ‚Üí scalable board dimension.
  - **snakes** ‚Üí mapping from snake head to tail.
  - **ladders** ‚Üí mapping from ladder bottom to top.

- Uses a strategy to initialize the layout (snakes and ladders).
- Provides getNextPosition() method to determine a player‚Äôs new position after movement.

**3. Player**

- Represents each participant in the game.

- **Attributes:**

  - `name`
  - `position`

- Handles player movement and boundary conditions.

**4. Dice**

- Responsible for generating random moves (1‚Äì6).
- Can be extended later for multiple dice or custom dice types.

**5. GameStrategy (Interface)**

- Abstract interface for all setup strategies.
- Declares setupBoard(Board&) to define how snakes and ladders are placed.

## üß† Strategy Pattern

The Strategy Pattern enables different ways to initialize the board without changing the core game logic.

**Implementations:**

**1. RandomSetupStrategy**

- Randomly places snakes and ladders across the board.
- Useful for testing or non-standard gameplay.

**2. CustomSetupStrategy**

- Uses predefined positions for snakes and ladders.
- Allows manual configuration for a desired challenge.

**3. StandardSetupStrategy**

- Follows the official or commonly used Snake and Ladder configuration.
- Provides a traditional gameplay experience.

## üîÅ Game Flow

**1. Game Initialization**

  - Select a board size.
  - Choose a setup strategy (Random, Custom, Standard).
  - Initialize the board.

**2. Gameplay Loop**

  - Each player rolls the dice in turn.
  - Move the player forward by the dice value.
  - Apply ladder or snake transitions.
  - Check for a winner.

**3. Winning Condition**

  - The first player reaching the last cell (board.size) wins.

---

## UML Diagram
!!! note ""
    ```mermaid
    classDiagram
        class Game {
            +Board board
            +List<Player> players
            +Dice dice
            +GameStrategy strategy
            +startGame()
            +playTurn(player: Player)
            +checkWinner() Player
        }
    
        class Board {
            +int size
            +Map<int, int> snakes
            +Map<int, int> ladders
            +initializeBoard(strategy: GameStrategy)
            +getNextPosition(pos: int) int
        }
    
        class Player {
            +String name
            +int position
            +move(steps: int)
        }
    
        class Dice {
            +int roll() int
        }
    
        class GameStrategy {
            <<interface>>
            +setupBoard(board: Board)
        }
    
        class RandomSetupStrategy {
            +setupBoard(board: Board)
        }
    
        class CustomSetupStrategy {
            +setupBoard(board: Board)
        }
    
        class StandardSetupStrategy {
            +setupBoard(board: Board)
        }
    
        %% Relationships
        Game --> Board
        Game --> Dice
        Game --> Player : manages *
        Game --> GameStrategy : uses
        Board --> GameStrategy : initialized by
        GameStrategy <|.. RandomSetupStrategy
        GameStrategy <|.. CustomSetupStrategy
        GameStrategy <|.. StandardSetupStrategy
    ```

---

## C++ Implementation
```cpp title="snake-&-ladder.cpp" linenums="1"
#include <bits/stdc++.h>
using namespace std;

// -------------------- Forward Declarations --------------------
class Board;

// -------------------- GameStrategy Interface --------------------
class GameStrategy {
public:
    virtual void setupBoard(Board& board) = 0;
    virtual ~GameStrategy() = default;
};

// -------------------- Board Class --------------------
class Board {
public:
    int size;
    unordered_map<int, int> snakes;
    unordered_map<int, int> ladders;

    Board(int s = 100) : size(s) {}

    void initializeBoard(GameStrategy& strategy) {
        strategy.setupBoard(*this);
    }

    int getNextPosition(int pos) {
        if (snakes.count(pos)) {
            cout << "Oops! Snake bite at " << pos << " ‚Üí " << snakes[pos] << "\n";
            return snakes[pos];
        }
        if (ladders.count(pos)) {
            cout << "Yay! Ladder at " << pos << " ‚Üí " << ladders[pos] << "\n";
            return ladders[pos];
        }
        return pos;
    }
};

// -------------------- Dice Class --------------------
class Dice {
public:
    int roll() {
        return rand() % 6 + 1;
    }
};

// -------------------- Player Class --------------------
class Player {
public:
    string name;
    int position;

    Player(string n) : name(n), position(0) {}

    void move(int steps, int boardSize) {
        position += steps;
        if (position > boardSize)
            position = boardSize - (position - boardSize);
    }
};

// -------------------- Concrete Strategies --------------------

// 1Ô∏è‚É£ Random Setup
class RandomSetupStrategy : public GameStrategy {
public:
    void setupBoard(Board& board) override {
        int snakeCount = 5, ladderCount = 5;
        srand(time(0));
        for (int i = 0; i < snakeCount; ++i) {
            int head = rand() % (board.size - 10) + 10;
            int tail = rand() % (head - 1) + 1;
            board.snakes[head] = tail;
        }
        for (int i = 0; i < ladderCount; ++i) {
            int bottom = rand() % (board.size - 10) + 1;
            int top = bottom + rand() % (board.size - bottom);
            board.ladders[bottom] = top;
        }
        cout << "[Board Setup: Random]\n";
    }
};

// 2Ô∏è‚É£ Custom Setup
class CustomSetupStrategy : public GameStrategy {
public:
    void setupBoard(Board& board) override {
        board.snakes = {{99, 54}, {70, 55}, {52, 42}, {25, 2}, {95, 72}};
        board.ladders = {{6, 25}, {11, 40}, {60, 85}, {46, 90}, {17, 69}};
        cout << "[Board Setup: Custom]\n";
    }
};

// 3Ô∏è‚É£ Standard Setup
class StandardSetupStrategy : public GameStrategy {
public:
    void setupBoard(Board& board) override {
        board.snakes = {{98, 78}, {95, 75}, {93, 73}, {87, 36}, {62, 19}, {56, 53}};
        board.ladders = {{1, 38}, {4, 14}, {9, 31}, {28, 84}, {21, 42}, {51, 67}, {71, 91}, {80, 100}};
        cout << "[Board Setup: Standard]\n";
    }
};

// -------------------- Game Class --------------------
class Game {
private:
    Board board;
    Dice dice;
    vector<Player> players;
    GameStrategy* strategy;

public:
    Game(int size, GameStrategy* strat, vector<string> playerNames)
        : board(size), strategy(strat) {
        for (auto& n : playerNames)
            players.emplace_back(n);
        board.initializeBoard(*strategy);
    }

    void startGame() {
        cout << "\nüéÆ Game Start!\n";
        bool won = false;
        while (!won) {
            for (auto& player : players) {
                int rollVal = dice.roll();
                cout << player.name << " rolls " << rollVal << "\n";
                player.move(rollVal, board.size);

                player.position = board.getNextPosition(player.position);
                cout << player.name << " is now at position " << player.position << "\n\n";

                if (player.position >= board.size) {
                    cout << "üèÜ " << player.name << " wins the game!\n";
                    won = true;
                    break;
                }
            }
        }
    }
};

// -------------------- Main Function --------------------
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<string> playerNames = {"Alice", "Bob"};

    // Choose a setup strategy
    // RandomSetupStrategy strategy;
    // CustomSetupStrategy strategy;
    StandardSetupStrategy strategy;

    // Create and start the game
    Game game(100, &strategy, playerNames);
    game.startGame();

    return 0;
}
```

---

## üîÆ Future Extensions

This design is open for extension and can evolve with minimal changes.

**Possible Enhancements:**

  - **Power-ups**: Tiles that give extra turns or protect from snakes.
  - **Penalty Tiles**: Skip turn or move backward effects.
  - **Multiplayer Networking**: Online player turns and leaderboard.
  - **Custom Dice Rules**: Weighted dice or dice with custom faces.
  - **AI Opponents**: Simulate computer-controlled players.

---

## üß≠ Design Pattern Used

- **Strategy Pattern**: For flexible board setup strategies.

- **Object-Oriented Design Principles**:

  - Encapsulation
  - Abstraction
  - Open‚ÄìClosed Principle
  - Single Responsibility Principle

---

## üèÅ Summary

This system design for Snake and Ladder ensures:

 - Flexibility in configuration.
 - Clean separation of concerns.
 - Ease of adding new features without disrupting existing logic.
