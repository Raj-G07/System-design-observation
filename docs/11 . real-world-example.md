# üß† Real-World Low-Level Design (LLD) Example ‚Äî Design a Parking Lot System

## üéØ Objective
Design a **Parking Lot Management System** that handles vehicle entry, exit, and payment in a real-world scenario using **Object-Oriented Design (OOD)** and **SOLID principles**.

---

## üèóÔ∏è 1. Problem Statement

You need to design a system for a parking lot with the following requirements:

### üß© Functional Requirements
- The parking lot has multiple floors.
- Each floor has multiple parking spots for different vehicle types (car, bike, truck).
- The system should:

  - Allow vehicles to **enter** and **exit**.
  - Issue a **parking ticket** on entry.
  - Calculate **parking charges** on exit.
  - Maintain status of parking spots (occupied/free).
  - Support different pricing for different vehicle types.

### ‚öôÔ∏è Non-Functional Requirements
- The design should be **extensible** (e.g., new vehicle types, new payment methods).
- The system should be **thread-safe** and **efficient**.
- Follow **SOLID principles** and **clean architecture**.

---

## üß± 2. Identifying Key Classes (LLD Breakdown)

| Entity | Responsibility |
|---------|----------------|
| `ParkingLot` | Entry point managing all floors and spots |
| `ParkingFloor` | Manages multiple parking spots |
| `ParkingSpot` | Represents an individual parking space |
| `Vehicle` | Abstract class for vehicles |
| `Car`, `Bike`, `Truck` | Concrete vehicle classes |
| `Ticket` | Represents parking ticket issued at entry |
| `Payment` | Handles payment processing |
| `EntranceGate`, `ExitGate` | Entry and exit control |
| `DisplayBoard` | Shows available spots per floor |

---

## üß© 3. UML Class Diagram (Conceptual)

```mermaid
classDiagram
    class ParkingLot {
        - floors: List<ParkingFloor>
        + getAvailableSpots(type: VehicleType): int
        + parkVehicle(vehicle: Vehicle): Ticket
        + exitVehicle(ticket: Ticket): double
    }

    class ParkingFloor {
        - spots: List<ParkingSpot>
        + getFreeSpot(type: VehicleType): ParkingSpot
    }

    class ParkingSpot {
        - id: int
        - type: VehicleType
        - isFree: bool
        + parkVehicle(vehicle: Vehicle)
        + removeVehicle()
    }

    class Vehicle {
        <<abstract>>
        - licensePlate: string
        - type: VehicleType
    }

    class Car
    class Bike
    class Truck

    Vehicle <|-- Car
    Vehicle <|-- Bike
    Vehicle <|-- Truck
    ParkingLot --> ParkingFloor
    ParkingFloor --> ParkingSpot
    ParkingSpot --> Vehicle
```

---

## üß© 4. Enumerations
```cpp title="enumerations.cpp" linenums="1"
enum class VehicleType {
    CAR,
    BIKE,
    TRUCK
};
```

---

## üí° 5. Class Implementations (C++ Example)
### üè† Vehicle Base Class
```cpp title="vehicle-base.cpp" linenums="1"
class Vehicle {
protected:
    std::string licensePlate;
    VehicleType type;
public:
    Vehicle(std::string plate, VehicleType t) : licensePlate(plate), type(t) {}
    virtual ~Vehicle() = default;

    VehicleType getType() const { return type; }
};
```

### üöó Derived Classes
```cpp title="vehicle-derived.cpp" linenums="1"
class Car : public Vehicle {
public:
    Car(std::string plate) : Vehicle(plate, VehicleType::CAR) {}
};

class Bike : public Vehicle {
public:
    Bike(std::string plate) : Vehicle(plate, VehicleType::BIKE) {}
};
```

### üÖøÔ∏è ParkingSpot Class
```cpp title="parking-spot.cpp" linenums="1"
class ParkingSpot {
    int id;
    VehicleType type;
    bool isFree;
    Vehicle* parkedVehicle;
public:
    ParkingSpot(int id, VehicleType t) : id(id), type(t), isFree(true), parkedVehicle(nullptr) {}

    bool getIsFree() const { return isFree; }
    VehicleType getType() const { return type; }

    void parkVehicle(Vehicle* v) {
        if (!isFree || v->getType() != type) throw std::runtime_error("Spot unavailable");
        parkedVehicle = v;
        isFree = false;
    }

    void removeVehicle() {
        parkedVehicle = nullptr;
        isFree = true;
    }
};
```

### üßæ Ticket Class
```cpp title="ticket.cpp" linenums="1"
class Ticket {
    std::string ticketId;
    time_t entryTime;
    Vehicle* vehicle;
public:
    Ticket(std::string id, Vehicle* v) : ticketId(id), vehicle(v) {
        entryTime = time(nullptr);
    }
    time_t getEntryTime() const { return entryTime; }
    Vehicle* getVehicle() const { return vehicle; }
};
```

### üí∞ Payment Class
```cpp title="payment.cpp" linenums="1"
class Payment {
public:
    static double calculateFee(VehicleType type, double hours) {
        switch (type) {
            case VehicleType::CAR: return hours * 20;
            case VehicleType::BIKE: return hours * 10;
            case VehicleType::TRUCK: return hours * 30;
        }
        return 0;
    }
};
```

## üîÑ 6. Flow of Control

- Vehicle enters ‚Üí entrance gate calls ParkingLot::parkVehicle().
- System finds free spot using ParkingFloor::getFreeSpot().
- Spot marked as occupied ‚Üí ticket issued.
- On exit ‚Üí exit gate calls ParkingLot::exitVehicle().
- System calculates duration & fee ‚Üí processes payment ‚Üí frees spot.

## üßÆ 7. Example Execution Flow
```cpp title="execution-flow.cpp" linenums="1"
int main() {
    ParkingSpot carSpot1(1, VehicleType::CAR);
    Car myCar("UP32-HBTU-999");

    try {
        carSpot1.parkVehicle(&myCar);
        std::cout << "Car parked successfully!\n";

        // Simulate parking duration
        double hours = 2.5;
        double amount = Payment::calculateFee(myCar.getType(), hours);
        std::cout << "Payment due: Rs. " << amount << std::endl;

        carSpot1.removeVehicle();
        std::cout << "Car exited successfully.\n";
    } catch (std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
}
```

## üîê 8. Key Design Principles Used
| Principle                 | Applied Example                                                                 |
| ------------------------- | ------------------------------------------------------------------------------- |
| **Single Responsibility** | Each class (Spot, Ticket, Payment) has one clear job                            |
| **Open/Closed**           | New vehicle types or pricing can be added without changing existing code        |
| **Liskov Substitution**   | All vehicles inherit from the same base class                                   |
| **Dependency Inversion**  | `ParkingLot` depends on abstractions (e.g., `VehicleType`) not concrete classes |
| **Encapsulation**         | Spot status and vehicle details are private                                     |

## üîó References

- [System Design Interview: Parking Lot Design ‚Äì Medium](https://medium.com/@interviewnoodle/parking-lot-design-interview-question-6b3d4f8a9b14)
- [GeeksforGeeks ‚Äì Object Oriented Design for Parking Lot](https://www.geeksforgeeks.org/system-design/design-parking-lot-using-object-oriented-principles/)
- [Refactoring Guru ‚Äì SOLID Principles](https://refactoring.guru/design-patterns/solid)
