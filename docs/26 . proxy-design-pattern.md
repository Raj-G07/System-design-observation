# ğŸ§° Proxy Design Pattern

## ğŸ“˜ Overview
!!! note ""
    The **Proxy Design Pattern** is a **structural pattern** that provides a **surrogate (substitute)** or **placeholder** for another object to control access to it.

    It acts as an **intermediary** between a client and a real object â€” useful for controlling creation, access, or communication with that object.

    > ğŸ§  In short: The proxy **wraps** another object to **add behavior** (like security, lazy loading, or remote access) without changing the real objectâ€™s code.

---

## ğŸ’¡ Real-World Analogy

Think of a **credit card** ğŸ’³ as a proxy for cash ğŸ’µ.  
You donâ€™t directly use cash â€” the card handles communication with the bank (real subject) and ensures proper authorization.

---

## ğŸ—ï¸ Structure

- **Subject** â†’ Common interface for Real Object and Proxy  
- **RealSubject** â†’ The real object doing the main work  
- **Proxy** â†’ Controls access to RealSubject (can add caching, access control, remote handling, etc.)  
- **Client** â†’ Interacts only with Proxy

---

## ğŸ§­ UML Class Diagram
!!! info ""
    ```mermaid
    classDiagram
        class Subject {
            + request()*
        }
    
        class RealSubject {
            + request() void
        }
    
        class Proxy {
            - realSubject : RealSubject*
            + request() void
        }
    
        Subject <|-- RealSubject
        Subject <|-- Proxy
        Proxy --> RealSubject
    ```

---

## ğŸ’» C++ Implementation
```cpp title="proxy-design.cpp" linenums="1"
#include <iostream>
#include <memory>
#include <string>
using namespace std;

class Subject {
public:
    virtual void request() const = 0;
    virtual ~Subject() = default;
};

class RealSubject : public Subject {
public:
    void request() const override {
        cout << "RealSubject: Handling request.\n";
    }
};

class Proxy : public Subject {
private:
    mutable unique_ptr<RealSubject> realSubject;

public:
    void request() const override {
        if (!realSubject) {
            cout << "Proxy: Creating RealSubject on demand (lazy initialization).\n";
            realSubject = make_unique<RealSubject>();
        }
        cout << "Proxy: Logging access before delegating.\n";
        realSubject->request();
    }
};

int main() {
    cout << "--- Using Proxy ---\n";
    Proxy proxy;
    proxy.request();   // First access - creates real subject
    proxy.request();   // Second access - reuses existing subject
}
```

---

## ğŸ§  Output
```vbnet
--- Using Proxy ---
Proxy: Creating RealSubject on demand (lazy initialization).
Proxy: Logging access before delegating.
RealSubject: Handling request.
Proxy: Logging access before delegating.
RealSubject: Handling request.
```

---

âš™ï¸ Types of Proxies
ğŸ§© 1. Virtual Proxy

Used for lazy loading â€” creates expensive objects only when needed.
```cpp title="virtual-proxy.cpp" linenums="1"
class VirtualImageProxy : public Subject {
    mutable unique_ptr<RealSubject> image;
public:
    void request() const override {
        if (!image) {
            cout << "Loading image from disk...\n";
            image = make_unique<RealSubject>();
        }
        image->request();
    }
};
```

ğŸ›¡ï¸ 2. Protection Proxy

Controls access based on permissions or roles.
```cpp title="protection-proxy.cpp" linenums="1"
class ProtectionProxy : public Subject {
    string userRole;
    unique_ptr<RealSubject> realSubject;

public:
    ProtectionProxy(string role) : userRole(move(role)), realSubject(make_unique<RealSubject>()) {}

    void request() const override {
        if (userRole == "Admin")
            realSubject->request();
        else
            cout << "Access Denied: User does not have permission.\n";
    }
};
```

ğŸŒ 3. Remote Proxy

Used to represent objects in a different address space (like on another server).
```cpp title="remote-proxy.cpp" linenums="1"
class RemoteProxy : public Subject {
public:
    void request() const override {
        cout << "RemoteProxy: Sending request to remote server...\n";
        cout << "Remote server response: 'Request processed successfully.'\n";
    }
};
```

---

## ğŸ§° When to Use

- When you want to control access to an object
- When the real object is expensive to create
- When the object resides in another process or machine
- When you need to add security or logging transparently

---

## âœ… Advantages

- Adds control without modifying real classes
- Supports lazy initialization
- Improves performance (e.g., via caching)
- Provides extra functionality (security, logging, etc.)

## âš ï¸ Drawbacks

- Increases complexity and number of classes
- Can introduce latency in remote proxies
- May violate the Single Responsibility Principle if overloaded with logic

## ğŸ”— References
???+ link 
     - [Refactoring Guru â€“ Proxy Pattern](https://refactoring.guru/design-patterns/proxy)
     - [GeeksforGeeks â€“ Proxy Design Pattern in C++](https://www.geeksforgeeks.org/system-design/proxy-design-pattern/)
     - [SourceMaking â€“ Proxy Pattern](https://sourcemaking.com/design_patterns/proxy)
