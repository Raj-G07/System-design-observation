# ğŸ“˜ Singleton Design Pattern

## ğŸ¯ Intent

The Singleton Pattern ensures that only one instance of a class exists in the entire application and provides a global point of access to it.

---

## ğŸ§  Real-World Analogy

Think of a printer spooler or an OS configuration manager â€”
no matter how many times you request it, you always get the same instance managing resources.

---

## âš™ï¸ Problem

In some systems, creating multiple instances of a class could cause:

- Conflicting states (e.g., multiple loggers writing inconsistently)
- Resource contention (e.g., multiple database connections)
- Increased memory usage

Hence, we restrict the instantiation to one object only.

---

## ğŸ§© UML Class Diagram

```mermaid
classDiagram
    class Singleton {
        - static instance : Singleton
        - Singleton()
        + static getInstance() : Singleton
        + someOperation() : void
    }

```

---

## ğŸ’» C++ Implementation

```cpp title="singleton-design.cpp" linenums="1"
#include <iostream>
#include <mutex>

class Singleton {
private:
    static Singleton* instance;
    static std::mutex mtx;

    // Private constructor
    Singleton() {
        std::cout << "Singleton Instance Created\n";
    }

public:
    // Delete copy/move operations
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    static Singleton* getInstance() {
        std::lock_guard<std::mutex> lock(mtx);
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    void showMessage() {
        std::cout << "Hello from Singleton instance!" << std::endl;
    }
};

// Initialize static members
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();

    s1->showMessage();

    if (s1 == s2)
        std::cout << "Both instances are the same (Singleton works!)" << std::endl;

    return 0;
}
```

---

## ğŸ§© Key Points

| Feature                 | Description                                                    |
| ----------------------- | -------------------------------------------------------------- |
| **Private Constructor** | Prevents creating objects with `new`                           |
| **Static Instance**     | Ensures only one instance exists                               |
| **Thread Safety**       | `std::mutex` ensures safe access in multithreaded environments |
| **Global Access Point** | `getInstance()` provides controlled access                     |

---

## ğŸ§± Advantages

- âœ… Controlled access to a single instance
- âœ… Reduces memory usage
- âœ… Ensures consistency across the application

---

##âš ï¸ Disadvantages

- âŒ Harder to unit test (global state)
- âŒ Violates Single Responsibility Principle (mixes object creation + logic)
- âŒ Can lead to hidden dependencies

---

##ğŸ’¡ When to Use

- Logging classes
- Database connection pools
- Configuration managers
- Thread pools

---

## ğŸ§® Alternative Approaches

- Use Dependency Injection frameworks (preferred in modern architectures)
- Use lazy initialization or smart pointers for better memory management

---

## ğŸ§­ Design Principle

> â€œEnsure a class has only one instance and provide a global access point to it.â€

---

## ğŸ”— References

- [Refactoring Guru â€” Singleton Pattern](https://refactoring.guru/design-patterns/singleton)
- [GeeksforGeeks â€” Singleton Design Pattern](https://www.geeksforgeeks.org/system-design/singleton-design-pattern-introduction/)
- [SourceMaking â€” Singleton](https://sourcemaking.com/design_patterns/singleton)
