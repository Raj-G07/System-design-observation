# üß† Design a Notification System 
## üéØ Objective

Design a flexible Notification System that can dynamically send notifications via SMS, Email, or Popup ‚Äî and easily extend to other channels (like WhatsApp, Push, Slack, etc.) without modifying the core system.

---

## üß© 1. Problem Statement

- You need to design a notification service that:
- Can send notifications to users through multiple channels.
- Should support plug-and-play extensibility ‚Äî adding a new channel must not break existing code.
- Should scale efficiently when the number of notifications increases.

---

## üß∞ 2. Functional Requirements

‚úÖ Send notifications via multiple channels:

- SMS
- Email
- Popup (in-app/web)

‚úÖ Add new channels easily (e.g., WhatsApp, Slack).
‚úÖ Dynamically increase notifications (load scaling).
‚úÖ Provide consistent message formatting.

---

## ‚öôÔ∏è 3. Non-Functional Requirements

| Concern           | Requirement                                                   |
| ----------------- | ------------------------------------------------------------- |
| **Scalability**   | System must handle a growing number of notifications          |
| **Extensibility** | New notification types can be added with minimal code changes |
| **Reusability**   | Common logic (message building, logging) should be shared     |
| **Reliability**   | Ensure message delivery retry mechanisms                      |

---

## üß± 4. UML Class Diagram
```mermaid
classDiagram
    class Notification {
        <<interface>>
        + send(message: string): void
    }

    class EmailNotification {
        + send(message: string): void
    }

    class SMSNotification {
        + send(message: string): void
    }

    class PopupNotification {
        + send(message: string): void
    }

    class NotificationFactory {
        + createNotification(type: string): Notification*
    }

    class NotificationManager {
        - notifications: vector~Notification*~
        + addChannel(n: Notification*)
        + notifyAll(message: string)
    }

    Notification <|.. EmailNotification
    Notification <|.. SMSNotification
    Notification <|.. PopupNotification
    NotificationFactory --> Notification
    NotificationManager --> Notification
```

---

## üí° 5. Design Approach

This design follows:

- Factory Pattern ‚Äî for creating notifications dynamically.
- Strategy Pattern ‚Äî each notification type implements its own strategy for sending messages.
- Open/Closed Principle (SOLID) ‚Äî easily add new types without changing existing code.

---

## üßÆ 6. C++ Implementation
```cpp title="notification-system.cpp" linenums="1"
#include <iostream>
#include <vector>
#include <memory>
#include <string>
using namespace std;

// ----- Notification Interface -----
class Notification {
public:
    virtual void send(const string& message) = 0;
    virtual ~Notification() = default;
};

// ----- Concrete Notification Types -----
class EmailNotification : public Notification {
public:
    void send(const string& message) override {
        cout << "üìß Sending Email: " << message << endl;
    }
};

class SMSNotification : public Notification {
public:
    void send(const string& message) override {
        cout << "üì± Sending SMS: " << message << endl;
    }
};

class PopupNotification : public Notification {
public:
    void send(const string& message) override {
        cout << "üí¨ Showing Popup: " << message << endl;
    }
};

// ----- Factory Pattern -----
class NotificationFactory {
public:
    static shared_ptr<Notification> createNotification(const string& type) {
        if (type == "email") return make_shared<EmailNotification>();
        else if (type == "sms") return make_shared<SMSNotification>();
        else if (type == "popup") return make_shared<PopupNotification>();
        else throw runtime_error("‚ùå Unknown notification type: " + type);
    }
};

// ----- Notification Manager -----
class NotificationManager {
    vector<shared_ptr<Notification>> notifications;
public:
    void addChannel(shared_ptr<Notification> n) {
        notifications.push_back(move(n));
    }

    void notifyAll(const string& message) {
        cout << "\nüîî Sending notifications...\n";
        for (auto& n : notifications)
            n->send(message);
    }
};

// ----- Main Program -----
int main() {
    NotificationManager manager;

    manager.addChannel(NotificationFactory::createNotification("email"));
    manager.addChannel(NotificationFactory::createNotification("sms"));
    manager.addChannel(NotificationFactory::createNotification("popup"));

    manager.notifyAll("Order #1234 has been shipped!");

    // Add new notification dynamically (plug & play)
    manager.addChannel(NotificationFactory::createNotification("sms"));
    manager.notifyAll("‚ö° Flash Sale: 50% off today!");

    return 0;
}
```

---

## üîÑ 7. Flow of Execution

- Factory creates notification objects dynamically.
- NotificationManager holds all active channels.
- When an event occurs ‚Üí all channels send messages simultaneously.
- You can plug in new notification types (e.g., WhatsAppNotification) without touching old code.

---

## üöÄ 8. Scalability (Dynamic Growth)

- To handle large volumes of notifications:
- Use Thread Pool / Message Queue (e.g., Kafka, RabbitMQ).
- Distribute messages asynchronously.
- Add retry logic and logging for failed sends.

---

## üß© 9. Adding a New Channel (WhatsApp Example)
```cpp title="whatsapp-example.cpp" linenums="1"
class WhatsAppNotification : public Notification {
public:
    void send(const string& message) override {
        cout << "üíö Sending WhatsApp Message: " << message << endl;
    }
};
manager.addChannel(make_shared<WhatsAppNotification>());
```
‚úÖ No existing code changed!

---

## üìò 10. References

- [GeeksforGeeks ‚Äì Design Notification System](https://www.geeksforgeeks.org/design-a-notification-system/)
- [Medium ‚Äì System Design: Notification Service](https://medium.com/@interviewnoodle/design-notification-system-86bffb12f7c8)
