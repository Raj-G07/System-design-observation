# Dating Site App â€” System Design
## ðŸ§  Overview

The Dating Site App connects users based on preferences, interests, and proximity. It allows users to create profiles, like or match with others, chat in real-time, and receive notifications for messages and matches.
The system follows a modular microservice-based architecture, ensuring scalability, reliability, and easy feature expansion.

## ðŸŽ¯ Objectives

- Support user authentication, profile creation, matchmaking, and real-time chat.
- Handle millions of concurrent users with low latency.
- Support push notifications and email alerts.
- Enable premium subscription plans and content moderation.

ðŸ—ï¸ Architecture Overview

The system is divided into four major layers:

**1. User Interface (Frontend)**

- Web and Mobile apps handle user interaction.

- Built with frameworks like React.js (web) and Flutter (mobile).

- Communicates with backend through REST or GraphQL APIs.

**2. Backend Services (Business Logic Layer)**

- Responsible for user authentication, matchmaking, chatting, and notifications.

- Follows service-oriented design â€” each feature runs as a microservice.

**3. Database & Storage Layer**

- Stores user profiles, chats, matches, and analytics logs.

- Media (photos, videos) is stored in cloud-based storage (e.g., AWS S3 or Cloudinary).

**4. External Integrations Layer**

- Integrates with 3rd-party APIs for notifications, payments, AI moderation, and maps.

## âš™ï¸ Core Components
**1. User Interface (Frontend)**

- Mobile App (React Native / Flutter)
- Web App (React.js)

- **Features:**

  - Swipe, like, and match interactions.
  - Real-time chat view.
  - Profile editing, photo upload, and discovery.

**2. Backend Services**
**ðŸ§¾ Authentication Service**

- Handles user signup, login, password reset, and OAuth (Google, Apple).
- Issues JWT or session tokens for secure communication.
- Manages premium subscription purchases via Payment Gateway.

**ðŸ‘¤ User Profile Service**

- Manages user data (bio, interests, gender, preferences, and media).
- Interfaces with AI Moderation API to detect and reject inappropriate content.
- Updates user visibility and search filters.

**ðŸ’ž Matchmaking Service**

- **Suggests potential matches using:**

  - Location-based filtering (via Geolocation API)
  - Preferences matching (age, gender, interests)
  - AI-driven recommendations (Recommendation Engine)

- Handles likes, super-likes, and match formation.

**ðŸ’¬ Chat Service**

- Provides real-time messaging for matched users only.
- Built with WebSockets or Socket.io.
- Stores messages in Chat Database.
- Notifies users of new messages via Notification Service.

**ðŸ”” Notification Service**

- **Sends push notifications, emails, or SMS alerts for:**

  - New matches
  - New messages
  - Subscription reminders

- Uses external Notification Gateway (e.g., Firebase, Twilio).

**ðŸ§  Recommendation Engine**

- Uses data from User DB and Match DB to compute compatibility scores.
- Applies algorithms like collaborative filtering or profile similarity scoring.
- Continuously improves with user interaction data.

**ðŸ› ï¸ Admin Dashboard Service**

- Allows admins to monitor system health, analytics, and user reports.
- Provides moderation tools (ban/suspend accounts).
- Displays metrics from the Analytics Database.

---

## 3. Database & Storage Layer
| Component               | Type                                | Description                                               |
| ----------------------- | ----------------------------------- | --------------------------------------------------------- |
| **User Database**       | Relational (e.g., PostgreSQL)       | Stores user details, preferences, and premium status.     |
| **Match Database**      | NoSQL / Graph                       | Tracks likes, dislikes, and mutual matches efficiently.   |
| **Chat Database**       | NoSQL (MongoDB / Redis)             | Stores chat messages and timestamps for real-time access. |
| **Media Storage**       | Object Store (S3/Cloudinary)        | Stores user images and videos.                            |
| **Analytics / Logs DB** | Time-series DB (Elastic / InfluxDB) | Tracks app events and logs for insights.                  |

## 4. UML Diagrams
```mermaid
flowchart TD

%% ===========================
%% USER INTERFACE LAYER
%% ===========================
subgraph UI["User Interface (Frontend)"]
    A1[Mobile App]
    A2[Web App]
end

A1 --> B[API Gateway]
A2 --> B

%% ===========================
%% BACKEND SERVICES
%% ===========================
subgraph Services["Backend Services"]
    B --> C1[Authentication Service]
    B --> C2[User Profile Service]
    B --> C3[Matchmaking Service]
    B --> C4[Chat Service]
    B --> C5[Notification Service]
    B --> C6[Recommendation Engine]
    B --> C7[Admin Dashboard Service]
end

%% ===========================
%% DATABASES
%% ===========================
subgraph DB["Databases & Storage"]
    D1[(User Database)]
    D2[(Match Database)]
    D3[(Chat Database)]
    D4[(Media Storage)]
    D5[(Analytics / Logs DB)]
end

%% ===========================
%% CONNECTIONS
%% ===========================
C1 --> D1
C2 --> D1
C3 --> D2
C4 --> D3
C5 --> D1
C6 --> D2
C7 --> D5

C6 --> D1
C6 --> D2

C5 --> E1[Push / Email / SMS Gateway]

C7 --> D1
C7 --> D2
C7 --> D3

%% ===========================
%% EXTERNAL INTEGRATIONS
%% ===========================
subgraph EXT["External Integrations"]
    E1[Notification Gateway]
    E2[Payment Gateway (Premium Plan)]
    E3[Geolocation / Map API]
    E4[AI Moderation / Image Filter API]
end

C2 --> E4
C3 --> E3
C1 --> E2

%% ===========================
%% ANALYTICS
%% ===========================
C7 --> F[Analytics Service]
F --> D5

%% ===========================
%% STYLES
%% ===========================
style UI fill:#E3F2FD,stroke:#2196F3,stroke-width:1px
style Services fill:#E8F5E9,stroke:#4CAF50,stroke-width:1px
style DB fill:#FFF8E1,stroke:#FFC107,stroke-width:1px
style EXT fill:#F3E5F5,stroke:#9C27B0,stroke-width:1px
```

---

## C++ Implementation
```cpp
// dating_app.cpp
// Simple C++ model of a Dating Site App architecture (synchronous simulation).
// Compile: g++ -std=c++17 dating_app.cpp -O2 -o dating_app && ./dating_app

#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>
#include <optional>
#include <set>

// -------------------------
// Databases & Storage
// -------------------------
struct User {
    int id;
    std::string username;
    std::string bio;
    std::string location;
    std::vector<std::string> photos;
};

struct Message {
    int fromUserId;
    int toUserId;
    std::string text;
};

class UserDB {
public:
    int createUser(const std::string &username) {
        int id = ++lastId;
        users[id] = User{id, username, "", "", {}};
        std::cout << "[UserDB] Created user '" << username << "' (id=" << id << ")\n";
        return id;
    }
    std::optional<User> getUser(int id) {
        if (users.count(id)) return users[id];
        return std::nullopt;
    }
    void updateUserProfile(int id, const std::string &bio, const std::string &location) {
        if (users.count(id)) {
            users[id].bio = bio;
            users[id].location = location;
            std::cout << "[UserDB] Updated profile for id=" << id << "\n";
        }
    }
    void addPhoto(int id, const std::string &photoUrl) {
        if (users.count(id)) {
            users[id].photos.push_back(photoUrl);
            std::cout << "[MediaStorage] Added photo for user " << id << ": " << photoUrl << "\n";
        }
    }
private:
    int lastId = 0;
    std::unordered_map<int, User> users;
};

class MatchDB {
public:
    void addLike(int from, int to) {
        likes[from].insert(to);
        std::cout << "[MatchDB] User " << from << " liked user " << to << "\n";
        // Check mutual like
        if (likes.count(to) && likes[to].count(from)) {
            matches.insert(makeKey(from, to));
            std::cout << "[MatchDB] Match found between " << from << " and " << to << "\n";
        }
    }
    bool isMatch(int a, int b) const {
        return matches.count(makeKey(a,b));
    }
private:
    std::unordered_map<int,std::set<int>> likes;
    std::set<std::string> matches;
    static std::string makeKey(int a, int b) {
        if (a < b) return std::to_string(a) + ":" + std::to_string(b);
        return std::to_string(b) + ":" + std::to_string(a);
    }
};

class ChatDB {
public:
    void storeMessage(const Message &m) {
        messages.push_back(m);
        std::cout << "[ChatDB] Stored message from " << m.fromUserId << " to " << m.toUserId << "\n";
    }
    const std::vector<Message>& getMessages() const { return messages; }
private:
    std::vector<Message> messages;
};

class AnalyticsDB {
public:
    void log(const std::string &event) {
        logs.push_back(event);
        std::cout << "[Analytics] " << event << "\n";
    }
private:
    std::vector<std::string> logs;
};

// -------------------------
// External Integrations (Mocks)
// -------------------------
class NotificationGateway {
public:
    void sendPush(int userId, const std::string &message) {
        std::cout << "[Push] -> user " << userId << ": " << message << "\n";
    }
    void sendEmail(int userId, const std::string &message) {
        std::cout << "[Email] -> user " << userId << ": " << message << "\n";
    }
};

class PaymentGateway {
public:
    bool charge(int userId, double amount) {
        std::cout << "[Payment] Charging user " << userId << " $" << amount << " ... OK\n";
        return true;
    }
};

class GeolocationAPI {
public:
    static double distanceKm(const std::string &aLoc, const std::string &bLoc) {
        // Mock: simple pseudo distance by string length difference (for demo)
        return std::abs((int)aLoc.length() - (int)bLoc.length()) * 1.5;
    }
};

class AIModerationAPI {
public:
    bool isImageSafe(const std::string &imageUrl) {
        // Mock: treat URLs containing "nsfw" as unsafe
        return imageUrl.find("nsfw") == std::string::npos;
    }
};

// -------------------------
// Backend Services
// -------------------------
class AuthenticationService {
public:
    AuthenticationService(UserDB &u, AnalyticsDB &a, PaymentGateway &p)
        : userDB(u), analytics(a), payment(p) {}

    int signup(const std::string &username) {
        int id = userDB.createUser(username);
        analytics.log("signup:user:" + std::to_string(id));
        return id;
    }

    bool purchasePremium(int userId) {
        if (payment.charge(userId, 9.99)) {
            analytics.log("purchase:premium:user:" + std::to_string(userId));
            return true;
        }
        return false;
    }
private:
    UserDB &userDB;
    AnalyticsDB &analytics;
    PaymentGateway &payment;
};

class UserProfileService {
public:
    UserProfileService(UserDB &u, AIModerationAPI &m, AnalyticsDB &a)
        : userDB(u), modApi(m), analytics(a) {}

    void updateProfile(int userId, const std::string &bio, const std::string &location) {
        userDB.updateUserProfile(userId, bio, location);
        analytics.log("profile:update:user:" + std::to_string(userId));
    }
    bool uploadPhoto(int userId, const std::string &url) {
        if (!modApi.isImageSafe(url)) {
            analytics.log("media:rejected:user:" + std::to_string(userId));
            std::cout << "[Moderation] Photo rejected for user " << userId << "\n";
            return false;
        }
        userDB.addPhoto(userId, url);
        analytics.log("media:uploaded:user:" + std::to_string(userId));
        return true;
    }
private:
    UserDB &userDB;
    AIModerationAPI &modApi;
    AnalyticsDB &analytics;
};

class MatchmakingService {
public:
    MatchmakingService(UserDB &u, MatchDB &m, AnalyticsDB &a, GeolocationAPI &g)
        : userDB(u), matchDB(m), analytics(a), geo(g) {}

    // Very naive matchmaking: likes are handled externally; this just suggests potential matches
    std::vector<int> suggestMatches(int userId) {
        std::vector<int> suggestions;
        auto maybeUser = userDB.getUser(userId);
        if (!maybeUser) return suggestions;
        User u = *maybeUser;
        // Suggest users with different id and small pseudo-distance
        for (int candidateId = 1; candidateId <= lastScannedUserId; ++candidateId) {
            if (candidateId == userId) continue;
            auto candOpt = userDB.getUser(candidateId);
            if (!candOpt) continue;
            User cand = *candOpt;
            double dist = GeolocationAPI::distanceKm(u.location, cand.location);
            if (dist < 10.0) suggestions.push_back(candidateId);
        }
        analytics.log("match:suggest:user:" + std::to_string(userId) +":count:" + std::to_string(suggestions.size()));
        return suggestions;
    }

    void setMaxUserIdScanned(int maxId) { lastScannedUserId = maxId; }
private:
    UserDB &userDB;
    MatchDB &matchDB;
    AnalyticsDB &analytics;
    GeolocationAPI &geo;
    int lastScannedUserId = 10;
};

class ChatService {
public:
    ChatService(ChatDB &cdb, MatchDB &mdb, NotificationGateway &ng, AnalyticsDB &a)
        : chatDB(cdb), matchDB(mdb), noti(ng), analytics(a) {}

    void sendMessage(int from, int to, const std::string &text) {
        // Only allow sending if a match exists
        if (!matchDB.isMatch(from, to)) {
            std::cout << "[ChatService] Can't send message: users not matched.\n";
            return;
        }
        Message m{from, to, text};
        chatDB.storeMessage(m);
        analytics.log("chat:msg:from:" + std::to_string(from) + ":to:" + std::to_string(to));
        noti.sendPush(to, "New message from user " + std::to_string(from));
    }

private:
    ChatDB &chatDB;
    MatchDB &matchDB;
    NotificationGateway &noti;
    AnalyticsDB &analytics;
};

class NotificationService {
public:
    NotificationService(NotificationGateway &g, AnalyticsDB &a) : gateway(g), analytics(a) {}
    void notifyMatch(int userId, const std::string &detail) {
        gateway.sendPush(userId, "You have a new match! " + detail);
        analytics.log("notify:match:user:" + std::to_string(userId));
    }
private:
    NotificationGateway &gateway;
    AnalyticsDB &analytics;
};

class RecommendationEngine {
public:
    RecommendationEngine(UserDB &u, MatchDB &m, AnalyticsDB &a) : userDB(u), matchDB(m), analytics(a) {}
    double compatibilityScore(int a, int b) {
        // Mock scoring: random/synthetic based on id parity
        double score = (a % 2 == b % 2) ? 0.8 : 0.5;
        analytics.log("reco:score:" + std::to_string(a) + ":" + std::to_string(b) + ":" + std::to_string(score));
        return score;
    }
private:
    UserDB &userDB;
    MatchDB &matchDB;
    AnalyticsDB &analytics;
};

class AdminDashboardService {
public:
    AdminDashboardService(AnalyticsDB &a) : analytics(a) {}
    void showBasicStats() {
        std::cout << "[Admin] (mock) Showing analytics summary ...\n";
        // For demo, nothing detailed
    }
private:
    AnalyticsDB &analytics;
};

// -------------------------
// API Gateway (coordinates requests)
// -------------------------
class APIGateway {
public:
    APIGateway(AuthenticationService &auth,
               UserProfileService &profile,
               MatchmakingService &match,
               ChatService &chat,
               NotificationService &notify,
               RecommendationEngine &reco)
        : auth(auth), profileService(profile), matchmaking(match),
          chatService(chat), notificationService(notify), recoEngine(reco) {}

    int signup(const std::string &username) {
        return auth.signup(username);
    }
    void updateProfile(int userId, const std::string &bio, const std::string &location) {
        profileService.updateProfile(userId, bio, location);
    }
    void uploadPhoto(int userId, const std::string &url) {
        if (!profileService.uploadPhoto(userId, url)) {
            std::cout << "[API] Upload failed for user " << userId << "\n";
        }
    }
    void likeUser(int from, int to, MatchDB &matchDB) {
        matchDB.addLike(from, to);
        if (matchDB.isMatch(from, to)) {
            notificationService.notifyMatch(from, "You matched with user " + std::to_string(to));
            notificationService.notifyMatch(to, "You matched with user " + std::to_string(from));
        }
    }
    void sendMessage(int from, int to, const std::string &text) {
        chatService.sendMessage(from, to, text);
    }

    void showRecommendations(int userId) {
        auto suggestions = matchmaking.suggestMatches(userId);
        std::cout << "[API] Recommendations for user " << userId << ": ";
        for (int id: suggestions) {
            double s = recoEngine.compatibilityScore(userId, id);
            std::cout << "(" << id << " score=" << s << ") ";
        }
        std::cout << "\n";
    }

private:
    AuthenticationService &auth;
    UserProfileService &profileService;
    MatchmakingService &matchmaking;
    ChatService &chatService;
    NotificationService &notificationService;
    RecommendationEngine &recoEngine;
};

// -------------------------
// Demo / Simulation
// -------------------------
int main() {
    // Instantiate DBs & external services
    UserDB userDB;
    MatchDB matchDB;
    ChatDB chatDB;
    AnalyticsDB analyticsDB;
    NotificationGateway notiGateway;
    PaymentGateway paymentGateway;
    AIModerationAPI modApi;
    GeolocationAPI geoApi;

    // Services
    AuthenticationService auth(userDB, analyticsDB, paymentGateway);
    UserProfileService profile(userDB, modApi, analyticsDB);
    MatchmakingService matchmaking(userDB, matchDB, analyticsDB, geoApi);
    ChatService chat(chatDB, matchDB, notiGateway, analyticsDB);
    NotificationService notification(notiGateway, analyticsDB);
    RecommendationEngine reco(userDB, matchDB, analyticsDB);
    AdminDashboardService admin(analyticsDB);

    // Set matchmaking to consider user IDs up to 5 for demo
    matchmaking.setMaxUserIdScanned(5);

    // API Gateway
    APIGateway api(auth, profile, matchmaking, chat, notification, reco);

    // Simulate some flows
    int alice = api.signup("alice");
    int bob   = api.signup("bob");
    int carol = api.signup("carol");

    api.updateProfile(alice, "Love hiking and coffee", "Bangalore");
    api.updateProfile(bob,   "Chef, foodie", "Bengaluru");
    api.updateProfile(carol, "Nature lover", "Mumbai");

    api.uploadPhoto(alice, "https://cdn.example.com/alice1.jpg");
    api.uploadPhoto(bob,   "https://cdn.example.com/bob1.jpg");
    api.uploadPhoto(carol, "https://cdn.example.com/carol_nsfw.jpg"); // simulated NSFW -> rejected

    // Likes and matching
    api.likeUser(alice, bob, matchDB);   // alice likes bob
    api.likeUser(bob, alice, matchDB);   // bob likes alice -> match

    // Recommendations
    api.showRecommendations(alice);

    // Chat
    api.sendMessage(alice, bob, "Hi Bob! Nice to meet you.");
    api.sendMessage(bob, alice, "Hey Alice! Great to match :)");

    // Payment demo
    auth.purchasePremium(bob);

    // Admin view
    admin.showBasicStats();

    // Print chat history
    std::cout << "\nChat Messages Stored:\n";
    for (const auto &m : chatDB.getMessages()) {
        std::cout << m.fromUserId << " -> " << m.toUserId << ": " << m.text << "\n";
    }

    std::cout << "\nSimulation complete.\n";
    return 0;
}
```

---

## ðŸ”„ Data Flow (Example)

- User signs up via the frontend â†’ request goes through API Gateway â†’ Authentication Service â†’ User Database.
- User uploads a photo â†’ User Profile Service calls AI Moderation API â†’ if approved, stored in Media Storage.
- User likes another profile â†’ Matchmaking Service updates Match Database â†’ if mutual, triggers Notification Service.
- Matched users chat â†’ messages stored in Chat Database â†’ notifications pushed in real-time.
- Admin monitors usage through Admin Dashboard Service, pulling logs from Analytics Database.

---

## ðŸ“ˆ Scalability & Reliability

- **Load Balancer**: Distributes traffic across multiple backend servers.

- **Caching Layer (Redis)**: Reduces DB reads for frequently accessed profiles.

- **CDN**: Delivers media content quickly across regions.

- **Database Replication**: Ensures availability and fault tolerance.

- **Horizontal Scaling**: Each microservice can scale independently based on load.

---

## ðŸ” Security & Compliance

- Secure password storage with bcrypt or Argon2.
- HTTPS for all communication.
- Rate limiting on API Gateway to prevent abuse.
- OAuth 2.0 and JWT for secure authentication.
- GDPR-compliant data handling and user consent.

---

## ðŸš€ Key Takeaways

- Designed for high scalability and low latency.
- Modular architecture enables easy addition of new features like video chat or AI matchmaking.
- AI-powered moderation and recommendations improve user safety and engagement.
- Built with clear separation of concerns between UI, business logic, and data layers.
