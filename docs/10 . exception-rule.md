# ‚ö†Ô∏è Exception Rule in Object-Oriented Design

The **Exception Rule** defines how software systems should handle **unexpected or abnormal situations** in a way that keeps the program **reliable, maintainable, and secure**.

In Object-Oriented Programming (OOP) and **System Design**, following the Exception Rule ensures that your system can **gracefully handle runtime errors** without breaking functionality or exposing internal states.

---

## üéØ What is the Exception Rule?

### üîπ Definition
> The **Exception Rule** states that a program should **detect, handle, and recover** from abnormal situations (exceptions) in a **controlled and predictable** manner.

It ensures:

- Errors are **not silently ignored**.  
- Code remains **clean, readable**, and **separated from normal logic**.  
- Failures are **contained** and **do not cascade** through the system.

---

## üß© Purpose of the Exception Rule

| Goal | Description |
|------|--------------|
| **Reliability** | Prevent system crashes from unhandled errors |
| **Maintainability** | Centralize error handling logic |
| **Readability** | Separate normal flow from error flow |
| **Security** | Avoid exposing sensitive details during failures |
| **Recovery** | Allow system to resume or exit gracefully |

---

## üß± Core Principles of the Exception Rule

### 1. **Throw Exceptions for Exceptional Cases Only**
- Use exceptions for **unexpected conditions**, not for normal control flow.
- Example: Don‚Äôt throw an exception for a user entering wrong credentials ‚Äî handle it logically.

```cpp
// ‚ùå Bad ‚Äî using exception for expected condition
if (username != "admin") throw invalid_argument("Invalid user");

// ‚úÖ Good ‚Äî handle logically
if (username != "admin") {
    cout << "Access denied" << endl;
}
```

### 2. Catch Exceptions at the Appropriate Level
- Don‚Äôt catch exceptions too early or too late.
- Catch them where meaningful recovery can be done.
  
```cpp
try {
    processPayment();
} catch (const NetworkError& e) {
    // ‚úÖ Correct: recoverable at this layer
    retryConnection();
} catch (const std::exception& e) {
    // ‚úÖ Log and terminate safely
    logError(e.what());
}
```

### 3. Don‚Äôt Swallow Exceptions
- Avoid empty catch blocks ‚Äî they hide bugs and make debugging impossible.
  
```cpp
try {
    performOperation();
} catch (...) {
    // ‚ùå Bad: hides the error
}
```
- ‚úÖ Instead:
- 
```cpp
catch (const std::exception& e) {
    cerr << "Error: " << e.what() << endl;
}
```

### 4. Use Custom Exception Classes
- Define specific exception types for different failure categories.
- This helps in granular handling of errors.

```cpp
class DatabaseException : public std::exception {
    const char* what() const noexcept override {
        return "Database connection failed!";
    }
};

class FileNotFoundException : public std::exception {
    const char* what() const noexcept override {
        return "File not found!";
    }
};
```

### 5. Maintain Exception Safety
> Exception-safe code ensures that even when an exception occurs, the system remains in a consistent and valid state.

- Levels of exception safety:
- Basic Guarantee ‚Äî No resource leaks.
- Strong Guarantee ‚Äî No side effects if an exception occurs.
- No-Throw Guarantee ‚Äî Function never throws exceptions.
  
```cpp
void safeFunction() noexcept {  // ‚úÖ No-throw guarantee
    // No exceptions will be thrown here
}
```

### 6. Clean Up Resources (RAII Principle)
- Use RAII (Resource Acquisition Is Initialization) to automatically free resources when exceptions occur.
  
```cpp
#include <fstream>

void readFile() {
    std::ifstream file("data.txt"); // Auto-managed
    if (!file.is_open()) throw std::runtime_error("Cannot open file!");
    // File auto-closes when function exits, even on exception
}
```
