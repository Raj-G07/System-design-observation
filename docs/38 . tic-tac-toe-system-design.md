# ðŸŽ® Tic-Tac-Toe System Design
## ðŸ§© Overview
!!! note "" 
    This document outlines the system design for a scalable, extendible Tic-Tac-Toe game application with in-app notifications for user moves, wins, and draws.
    The system is modular, allowing new game rules, custom board sizes, and potential integration with real-time multiplayer or push notification services.

## âš™ï¸ Functional Requirements

**1. Scalable Board Size**

- The board should support variable dimensions (3Ã—3, 4Ã—4, NxN).
- Should easily accommodate changes without modifying core logic.

**2. Extendible Game Rules**

- The rule engine should support modifications (e.g., new win conditions, time-based play).
- Must follow standard Tic-Tac-Toe rules by default.

**3. In-App Notifications**

- Notify users for each move, win, and draw event.
- Should support integration with both in-app and external push notification services.

**4. Game Flow Management**

- Maintain smooth gameplay handling turn alternation, move validation, and result determination.
- Persist game state (for history, replays, or reconnection scenarios).

---

## ðŸ§± System Components

**1. Client Side**

   - **Game UI:**
     Displays the board, player turns, and result notifications.

   - **Input Handler:**
     Captures user moves and sends them to the backend for validation.

   - **Notifier:**
     Displays in-app messages for events like invalid moves, wins, and draws.

**2. Server Side**

   - **Game Controller:**
     Acts as the central manager that coordinates between all modules â€” processes user moves, communicates with the rules engine, and updates the game state.

   - **Rules Engine:**
     Handles move validation, win/draw detection, and supports extensibility for new rule sets.

   - **Board Manager:**
     Maintains the board state. Supports scalable configurations like 3Ã—3, 4Ã—4, or larger boards.

   - **Notification Service:**
     Manages communication of in-app events and integrates with external push notification APIs.

   - **Database:**
     Stores user progress, game states, and match histories for persistence.

**3. External Services**

   - **Push Notification API:**
     Enables external notifications for real-time alerts when the game is extended beyond local play.

---

## ðŸ”„ System Workflow

1. User interacts with the UI to make a move.
2. The Input Handler forwards this to the Game Controller.
3. The Game Controller verifies move validity using the Rules Engine.
4. If valid, the Board Manager updates the board state.
5. Rules Engine checks for a win, draw, or ongoing state.
6. Notification Service sends in-app and/or external notifications based on the result.
7. The UI updates accordingly with real-time feedback.

---

## ðŸ”§ Design Principles

- **Modularity:**
   Each component (RulesEngine, BoardManager, NotificationService) is independent and replaceable.

- **Scalability:**
  The system supports dynamic board resizing and additional features without redesigning the architecture.

- **Extensibility:**
  Future enhancements like multiplayer, custom rule modes, or analytics can be easily added.

- **Reusability:**
  Core modules (e.g., Rules Engine, Notifier) can be reused for other board games.

---

## UML Diagram
!!! note ""
    ```mermaid
    flowchart TD
    
    subgraph Client["ðŸŽ® Client Side (Mobile/Web App)"]
        UI["Game UI\n(Board, Score, Status)"]
        InputHandler["Input Handler\n(User Move Listener)"]
        Notifier["In-App Notification System"]
    end
    
    subgraph Server["ðŸ§  Server Side"]
        GameController["Game Controller\n(Manages Game Flow)"]
        RulesEngine["Rules Engine\n(Validates Moves, Checks Win/Draw)"]
        BoardManager["Board Manager\n(Scalable Board Configurations)"]
        NotificationService["Notification Service\n(Sends Move/Result Updates)"]
        DB["Database\n(Stores Game States & History)"]
    end
    
    subgraph External["ðŸ”” External Services"]
        PushAPI["Push Notification API"]
    end
    
    %% Connections
    UI --> InputHandler
    InputHandler --> GameController
    GameController --> RulesEngine
    GameController --> BoardManager
    RulesEngine --> GameController
    GameController --> DB
    GameController --> NotificationService
    NotificationService --> Notifier
    NotificationService --> PushAPI
    Notifier --> UI
    
    %% Extension Paths
    RulesEngine -.-> ExtRules["Extendible Rules Module\n(e.g., Custom Game Modes)"]
    BoardManager -.-> ExtBoard["Dynamic Board Scaling\n(3x3, 4x4, NxN)"]
    
    ```

---

## C++ Implementation
```cpp title="tic-tac-toe.cpp" linenums="1"
#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <unordered_map>

using namespace std;

/* ============================
   ðŸŽ® CLIENT SIDE
   ============================ */
class Notifier {
public:
    void notify(const string& message) {
        cout << "[NOTIFICATION] " << message << endl;
    }
};

class UI {
public:
    void renderBoard(const vector<vector<char>>& board) {
        cout << "\nCurrent Board:\n";
        for (auto& row : board) {
            for (auto& cell : row)
                cout << (cell == '\0' ? '.' : cell) << " ";
            cout << "\n";
        }
        cout << endl;
    }

    void showMessage(const string& msg) {
        cout << msg << endl;
    }
};

/* ============================
   ðŸ§  SERVER SIDE
   ============================ */

class BoardManager {
    int size;
    vector<vector<char>> board;
public:
    BoardManager(int n = 3) : size(n), board(n, vector<char>(n, '\0')) {}

    void reset() { board.assign(size, vector<char>(size, '\0')); }
    bool makeMove(int row, int col, char player) {
        if (row < 0 || col < 0 || row >= size || col >= size || board[row][col] != '\0')
            return false;
        board[row][col] = player;
        return true;
    }
    const vector<vector<char>>& getBoard() const { return board; }
    int getSize() const { return size; }
};

class RulesEngine {
public:
    bool checkWin(const vector<vector<char>>& board, char player) {
        int n = board.size();

        // Check rows & columns
        for (int i = 0; i < n; ++i) {
            bool rowWin = true, colWin = true;
            for (int j = 0; j < n; ++j) {
                if (board[i][j] != player) rowWin = false;
                if (board[j][i] != player) colWin = false;
            }
            if (rowWin || colWin) return true;
        }

        // Check diagonals
        bool diag1 = true, diag2 = true;
        for (int i = 0; i < n; ++i) {
            if (board[i][i] != player) diag1 = false;
            if (board[i][n - i - 1] != player) diag2 = false;
        }
        return diag1 || diag2;
    }

    bool isDraw(const vector<vector<char>>& board) {
        for (auto& row : board)
            for (auto& cell : row)
                if (cell == '\0') return false;
        return true;
    }
};

class NotificationService {
    shared_ptr<Notifier> notifier;
public:
    NotificationService(shared_ptr<Notifier> n) : notifier(move(n)) {}
    void send(const string& message) {
        notifier->notify(message);
    }
};

class GameController {
    BoardManager boardManager;
    RulesEngine rulesEngine;
    NotificationService notificationService;
    UI ui;
    char currentPlayer = 'X';

public:
    GameController(int size, shared_ptr<Notifier> notifier)
        : boardManager(size), notificationService(notifier) {}

    void startGame() {
        ui.showMessage("Tic-Tac-Toe Game Started!");
        boardManager.reset();

        while (true) {
            ui.renderBoard(boardManager.getBoard());
            int row, col;
            cout << "Player " << currentPlayer << " - Enter row and col: ";
            cin >> row >> col;

            if (!boardManager.makeMove(row, col, currentPlayer)) {
                ui.showMessage("Invalid move, try again!");
                continue;
            }

            ui.renderBoard(boardManager.getBoard());
            notificationService.send("Player " + string(1, currentPlayer) + " made a move.");

            if (rulesEngine.checkWin(boardManager.getBoard(), currentPlayer)) {
                notificationService.send("Player " + string(1, currentPlayer) + " wins!");
                ui.showMessage("Game Over!");
                break;
            } else if (rulesEngine.isDraw(boardManager.getBoard())) {
                notificationService.send("It's a draw!");
                ui.showMessage("Game Over!");
                break;
            }

            // Switch player
            currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';
        }
    }
};

/* ============================
   MAIN FUNCTION
   ============================ */
int main() {
    auto notifier = make_shared<Notifier>();
    GameController game(3, notifier);
    game.startGame();
    return 0;
}
```

---

## ðŸš€ Future Enhancements

- **Real-Time Multiplayer Mode:**
Implement WebSocket-based communication for remote gameplay.

- **AI Opponent:**
Integrate a minimax-based or heuristic AI module for single-player mode.

- **User Authentication:**
Allow login, user history tracking, and leaderboard features.

- **Cloud Notifications:**
Integrate Firebase Cloud Messaging (FCM) or AWS SNS for cross-platform alerts.

---

## ðŸ“˜ Summary

This design ensures a clean separation of concerns, flexibility for growth, and maintainability.
By modularizing the board, rule, and notification systems, the Tic-Tac-Toe app can evolve into a complete, scalable multiplayer platform.
