# Chain of Responsibility Design Pattern

The **Chain of Responsibility (CoR)** design pattern is a **behavioral pattern** that allows multiple objects a chance to handle a request, without explicitly coupling the sender to the receiver.  
The request is passed along a **chain of handlers**, and each handler either processes it or passes it further down the chain.

---

## ğŸ§© Key Concepts

- **Decouples sender and receiver** â€” the sender doesnâ€™t know who handles the request.
- **Handlers are linked dynamically**, forming a chain.
- **Promotes flexibility and reusability**, as new handlers can be added easily.

---

## ğŸ“Š UML Diagram
!!! info ""
    ```mermaid
    classDiagram
        class Handler {
            - successor : Handler*
            + setSuccessor(Handler*) : void
            + handleRequest(int) : void
        }
    
        class ConcreteHandler1 {
            + handleRequest(int) : void
        }
    
        class ConcreteHandler2 {
            + handleRequest(int) : void
        }
    
        Handler <|-- ConcreteHandler1
        Handler <|-- ConcreteHandler2
        ConcreteHandler1 --> Handler : successor
        ConcreteHandler2 --> Handler : successor
    ```

---

## ğŸ’» C++ Implementation

```cpp title="cor-design.cpp" linenums="1"
#include <iostream>
using namespace std;

// Abstract Handler
class Handler {
protected:
    Handler* successor = nullptr;
public:
    virtual ~Handler() = default;

    void setSuccessor(Handler* next) {
        successor = next;
    }

    virtual void handleRequest(int level) {
        if (successor)
            successor->handleRequest(level);
    }
};

// Concrete Handler 1
class LowLevelHandler : public Handler {
public:
    void handleRequest(int level) override {
        if (level < 5) {
            cout << "LowLevelHandler handled request of level " << level << endl;
        } else if (successor) {
            successor->handleRequest(level);
        }
    }
};

// Concrete Handler 2
class HighLevelHandler : public Handler {
public:
    void handleRequest(int level) override {
        if (level >= 5) {
            cout << "HighLevelHandler handled request of level " << level << endl;
        } else if (successor) {
            successor->handleRequest(level);
        }
    }
};

// Client code
int main() {
    LowLevelHandler low;
    HighLevelHandler high;

    low.setSuccessor(&high);

    int requests[] = {2, 6, 1, 8};
    for (int req : requests)
        low.handleRequest(req);

    return 0;
}
```

---

## ğŸ§  Output:
```pgsql linenums="1"
LowLevelHandler handled request of level 2
HighLevelHandler handled request of level 6
LowLevelHandler handled request of level 1
HighLevelHandler handled request of level 8
```

---

## âš™ï¸ Real-world Analogy

Imagine a technical support system:

- Level 1 agent handles basic issues.
- If not resolved, it goes to Level 2.
- If still unresolved, it escalates to Level 3.

Each handler decides whether to process or forward the request.

## ğŸ”— Reference

- [Refactoring.Guru â€“ Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility)
- [SourceMaking â€“ Chain of Responsibility Pattern](https://sourcemaking.com/design_patterns/chain_of_responsibility)
