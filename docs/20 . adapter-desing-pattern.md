# ðŸ§© Adapter Design Pattern

## ðŸ“˜ Overview

The **Adapter Design Pattern** is a **structural design pattern** that allows objects with incompatible interfaces to collaborate.  
It acts as a **bridge** between two incompatible interfaces â€” wrapping one object so that it can be used as another.

---

## ðŸ’¡ Real-World Analogy

Think of a **mobile charger** â€” your phoneâ€™s charging port might be USB-C, but the socket is a regular plug.  
The **charger acts as an adapter** that converts electrical power from one interface to another.

---

## ðŸ”§ Structure

- **Target** â†’ Defines the domain-specific interface used by the client.  
- **Adaptee** â†’ Has an existing interface that needs adapting.  
- **Adapter** â†’ Adapts the interface of the adaptee to the target interface.  
- **Client** â†’ Works with Target through the Adapter.

---

## ðŸ§­ UML Diagram

```mermaid
classDiagram
    class Target {
        + request() void
    }

    class Adaptee {
        + specificRequest() void
    }

    class Adapter {
        - adaptee : Adaptee
        + Adapter(adaptee : Adaptee)
        + request() void
    }

    Target <|-- Adapter
    Adapter --> Adaptee
```

---

## ðŸ’» C++ Implementation
``` cpp
#include <iostream>
using namespace std;

// Target interface
class Target {
public:
    virtual void request() const {
        cout << "Target: Default target behavior." << endl;
    }
    virtual ~Target() = default;
};

// Adaptee with a different interface
class Adaptee {
public:
    void specificRequest() const {
        cout << "Adaptee: Specific behavior (incompatible interface)." << endl;
    }
};

// Adapter makes Adaptee compatible with Target
class Adapter : public Target {
private:
    Adaptee* adaptee;

public:
    Adapter(Adaptee* a) : adaptee(a) {}
    void request() const override {
        cout << "Adapter: Translating request -> ";
        adaptee->specificRequest();
    }
};

// Client code
int main() {
    Adaptee* adaptee = new Adaptee;
    Target* adapter = new Adapter(adaptee);

    cout << "Client: I can work with Target objects:\n";
    adapter->request();

    delete adapter;
    delete adaptee;
    return 0;
}
```

---

## ðŸ§  Key Points

âœ… The Adapter pattern is especially useful when:

- You want to reuse existing classes with incompatible interfaces.
- Youâ€™re working with legacy code that cannot be modified.
- You need to integrate third-party libraries smoothly.

## ðŸ”— References

- [Refactoring Guru â€“ Adapter Pattern](https://refactoring.guru/design-patterns/adapter)
- [GeeksforGeeks â€“ Adapter Design Pattern in C++](https://www.geeksforgeeks.org/system-design/adapter-pattern/)
