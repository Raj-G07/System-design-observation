# ğŸ§± Facade Design Pattern

## ğŸ“˜ Overview

The **Facade Design Pattern** is a **structural pattern** that provides a **simplified interface** to a complex subsystem.  
It hides the complexity of multiple classes behind a single unified interface, making the subsystem easier to use.

---

## ğŸ’¡ Real-World Analogy

Imagine you're ordering food at a restaurant ğŸ½ï¸.  
Instead of interacting with the **chef**, **waiters**, and **cashier** individually, you just **talk to one waiter (facade)** who handles everything behind the scenes.  
Thatâ€™s the essence of the Facade pattern.

---

## ğŸ”§ Structure

- **Facade** â†’ Provides a simple interface to the complex subsystem.  
- **Subsystem Classes** â†’ Implement detailed functionality but are accessed through the facade.  
- **Client** â†’ Interacts only with the facade.

---

## ğŸ§­ UML Diagram

```mermaid
classDiagram
    class Facade {
        + operation() void
    }

    class SubsystemA {
        + operationA() void
    }

    class SubsystemB {
        + operationB() void
    }

    class SubsystemC {
        + operationC() void
    }

    Facade --> SubsystemA
    Facade --> SubsystemB
    Facade --> SubsystemC
```

---

## ğŸ’» C++ Implementation
```cpp
#include <iostream>
using namespace std;

// Subsystem A
class SubsystemA {
public:
    void operationA() const {
        cout << "SubsystemA: Operation A executed.\n";
    }
};

// Subsystem B
class SubsystemB {
public:
    void operationB() const {
        cout << "SubsystemB: Operation B executed.\n";
    }
};

// Subsystem C
class SubsystemC {
public:
    void operationC() const {
        cout << "SubsystemC: Operation C executed.\n";
    }
};

// Facade class
class Facade {
private:
    SubsystemA* a;
    SubsystemB* b;
    SubsystemC* c;

public:
    Facade() {
        a = new SubsystemA();
        b = new SubsystemB();
        c = new SubsystemC();
    }

    ~Facade() {
        delete a;
        delete b;
        delete c;
    }

    void operation() const {
        cout << "Facade: Coordinating subsystems...\n";
        a->operationA();
        b->operationB();
        c->operationC();
    }
};

// Client code
int main() {
    Facade facade;
    facade.operation();
    return 0;
}
```

---

## ğŸ§  Key Points

âœ… Simplifies complex systems by exposing a unified API.
âœ… Reduces dependencies between client code and subsystem classes.
âœ… Increases maintainability by isolating changes within subsystems.
âœ… Ideal for library wrappers, SDKs, and large applications.

## âš™ï¸ Real-World Example

In a video conversion tool, the Facade might expose a single function convertVideo("file.mp4", "avi")
â€” while internally it coordinates with subsystems for file reading, codec conversion, and compression.

## ğŸ”— References

- [Refactoring Guru â€“ Facade Pattern](https://refactoring.guru/design-patterns/facade)
- [GeeksforGeeks â€“ Facade Design Pattern in C++](https://www.geeksforgeeks.org/system-design/facade-design-pattern-introduction/)
- [SourceMaking â€“ Facade Pattern](https://sourcemaking.com/design_patterns/facade)
