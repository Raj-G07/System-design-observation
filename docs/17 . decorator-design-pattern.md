# üé® Decorator Design Pattern

## üß† Intent

The Decorator Design Pattern allows you to dynamically add new behavior or responsibilities to an object without modifying its structure.
It‚Äôs part of the Structural Design Patterns family and promotes composition over inheritance.

---

##‚ö° Problem

Imagine you are building a Coffee Ordering System.
You start with a simple `Coffee` class.
Later, you want to add:

- Milk ‚òï
- Sugar üç¨
- Whipped Cream üç¶
- Caramel üçØ
Instead of creating dozens of subclasses like MilkCoffee, SugarCoffee, MilkSugarCoffee, etc.,
you can use decorators to add features dynamically at runtime.

---

## üí° Solution

- Create a Component interface that defines the core behavior (getCost(), getDescription()).
- Implement a Concrete Component (e.g., SimpleCoffee).
- Create an Abstract Decorator that also implements the same interface and wraps another component.
- Extend decorators like MilkDecorator, SugarDecorator, etc., to enhance behavior.

---

## üß± UML Class Diagram
```mermaid
classDiagram
    class Coffee {
        <<interface>>
        + getCost() : double
        + getDescription() : string
    }

    class SimpleCoffee {
        + getCost() : double
        + getDescription() : string
    }

    class CoffeeDecorator {
        - coffee : Coffee
        + getCost() : double
        + getDescription() : string
    }

    class MilkDecorator {
        + getCost() : double
        + getDescription() : string
    }

    class SugarDecorator {
        + getCost() : double
        + getDescription() : string
    }

    Coffee <|.. SimpleCoffee
    Coffee <|.. CoffeeDecorator
    CoffeeDecorator <|-- MilkDecorator
    CoffeeDecorator <|-- SugarDecorator
    CoffeeDecorator --> Coffee : wraps
```

---

## ‚öôÔ∏è C++ Implementation
```cpp title="decorator-design.cpp" linenums="1"
#include <iostream>
#include <memory>
using namespace std;

// ----- Component Interface -----
class Coffee {
public:
    virtual double getCost() const = 0;
    virtual string getDescription() const = 0;
    virtual ~Coffee() = default;
};

// ----- Concrete Component -----
class SimpleCoffee : public Coffee {
public:
    double getCost() const override { return 50.0; }
    string getDescription() const override { return "Simple Coffee"; }
};

// ----- Abstract Decorator -----
class CoffeeDecorator : public Coffee {
protected:
    shared_ptr<Coffee> coffee;
public:
    CoffeeDecorator(shared_ptr<Coffee> c) : coffee(move(c)) {}
};

// ----- Concrete Decorators -----
class MilkDecorator : public CoffeeDecorator {
public:
    MilkDecorator(shared_ptr<Coffee> c) : CoffeeDecorator(move(c)) {}
    double getCost() const override { return coffee->getCost() + 20.0; }
    string getDescription() const override { return coffee->getDescription() + ", Milk"; }
};

class SugarDecorator : public CoffeeDecorator {
public:
    SugarDecorator(shared_ptr<Coffee> c) : CoffeeDecorator(move(c)) {}
    double getCost() const override { return coffee->getCost() + 10.0; }
    string getDescription() const override { return coffee->getDescription() + ", Sugar"; }
};

class CaramelDecorator : public CoffeeDecorator {
public:
    CaramelDecorator(shared_ptr<Coffee> c) : CoffeeDecorator(move(c)) {}
    double getCost() const override { return coffee->getCost() + 30.0; }
    string getDescription() const override { return coffee->getDescription() + ", Caramel"; }
};

// ----- Client Code -----
int main() {
    shared_ptr<Coffee> coffee = make_shared<SimpleCoffee>();
    cout << coffee->getDescription() << " ‚Üí ‚Çπ" << coffee->getCost() << endl;

    coffee = make_shared<MilkDecorator>(coffee);
    coffee = make_shared<SugarDecorator>(coffee);
    coffee = make_shared<CaramelDecorator>(coffee);

    cout << coffee->getDescription() << " ‚Üí ‚Çπ" << coffee->getCost() << endl;
}
```

---

## üß© Output
```nginx
Simple Coffee ‚Üí ‚Çπ50
Simple Coffee, Milk, Sugar, Caramel ‚Üí ‚Çπ110
```

---

## üß† Key Design Concepts
| Principle                        | Description                                                   |
| -------------------------------- | ------------------------------------------------------------- |
| **Open/Closed Principle**        | You can add new behavior without modifying existing code      |
| **Composition Over Inheritance** | Behavior is added dynamically using object composition        |
| **Single Responsibility**        | Each decorator focuses on one enhancement (e.g., sugar, milk) |

---

## üöÄ Real-World Use Cases
| Domain               | Example                                                          |
| -------------------- | ---------------------------------------------------------------- |
| **UI Frameworks**    | Adding scrollbars, borders, shadows to windows or widgets        |
| **Middleware**       | Adding logging, authentication, and caching around core services |
| **Game Development** | Adding power-ups to characters dynamically                       |
| **Data Processing**  | Wrapping data streams with filters or compression decorators     |

## üß© Advantages

‚úÖ Flexible and reusable design
‚úÖ Promotes modularity and scalability
‚úÖ Reduces subclass explosion
‚úÖ Runtime behavior modification

## ‚ö†Ô∏è Disadvantages

‚ùå Increases complexity due to multiple small objects
‚ùå Debugging can become difficult with multiple layers of wrapping

## üîó References

- [Refactoring.Guru ‚Äì Decorator Pattern](https://refactoring.guru/design-patterns/decorator)
- [SourceMaking ‚Äì Decorator Pattern](https://sourcemaking.com/design_patterns/decorator)
- [GeeksforGeeks ‚Äì Decorator Design Pattern](https://www.geeksforgeeks.org/system-design/decorator-pattern/)
- [Wikipedia ‚Äì Decorator Pattern](https://en.wikipedia.org/wiki/Decorator_pattern)
