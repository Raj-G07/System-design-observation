# ğŸ§± With and Without Builder Design Pattern

The **Builder Pattern** helps in constructing complex objects step by step â€” especially when the object requires **many configurations**.  
Without it, object creation can get messy with telescoping constructors or deeply nested initialization.

---

## âš™ï¸ Problem: Building a Computer Object

We want to create a `Computer` with parts like **CPU**, **GPU**, **RAM**, **Storage**, and **Power Supply**.

---

## âŒ Without Builder Pattern

When not using the Builder pattern, we often end up with **telescoping constructors** or **many setters**, making the code hard to read and maintain.

### ğŸ§© C++ Implementation

```cpp title="without-builder.cpp" linenums="1"
#include <iostream>
#include <string>
using namespace std;

class Computer {
    string cpu;
    string gpu;
    int ram;
    int storage;
    string powerSupply;

public:
    Computer(string cpu, string gpu, int ram, int storage, string powerSupply)
        : cpu(cpu), gpu(gpu), ram(ram), storage(storage), powerSupply(powerSupply) {}

    void show() const {
        cout << "Computer Specifications:\n";
        cout << "CPU: " << cpu << "\nGPU: " << gpu
             << "\nRAM: " << ram << "GB\nStorage: " << storage
             << "GB\nPower Supply: " << powerSupply << endl;
    }
};

int main() {
    // Must pass all arguments even if some are optional
    Computer gamingPC("Intel i9", "RTX 4080", 32, 2000, "850W PSU");
    gamingPC.show();
    return 0;
}
```

---

## ğŸš« Issues

- Hard to remember parameter order.
- Cannot easily create variants (e.g., BasicPC, GamingPC).
- Code becomes unmaintainable when more attributes are added.
- Optional parameters clutter constructors.

---

## âœ… With Builder Pattern

The Builder Pattern solves these issues by constructing the object step-by-step.
It separates the construction logic from the representation.

## UML Diagram
!!! note ""
    ```mermaid
    classDiagram
        class Computer {
            - cpu : string
            - gpu : string
            - ram : int
            - storage : int
            - powerSupply : string
            + show() : void
        }
    
        class ComputerBuilder {
            - cpu : string
            - gpu : string
            - ram : int
            - storage : int
            - powerSupply : string
            + setCPU(string) : ComputerBuilder&
            + setGPU(string) : ComputerBuilder&
            + setRAM(int) : ComputerBuilder&
            + setStorage(int) : ComputerBuilder&
            + setPowerSupply(string) : ComputerBuilder&
            + build() : Computer
        }
    
        ComputerBuilder --> Computer
    ```

---

## ğŸ’» C++ Implementation (With Builder)
```cpp title="with-builder.cpp" linenums="1"
#include <iostream>
#include <string>
using namespace std;

class Computer {
    string cpu;
    string gpu;
    int ram;
    int storage;
    string powerSupply;

public:
    Computer(string cpu, string gpu, int ram, int storage, string powerSupply)
        : cpu(cpu), gpu(gpu), ram(ram), storage(storage), powerSupply(powerSupply) {}

    void show() const {
        cout << "Computer Specifications:\n";
        cout << "CPU: " << cpu << "\nGPU: " << gpu
             << "\nRAM: " << ram << "GB\nStorage: " << storage
             << "GB\nPower Supply: " << powerSupply << endl;
    }
};

class ComputerBuilder {
    string cpu = "Unknown";
    string gpu = "Integrated";
    int ram = 8;
    int storage = 256;
    string powerSupply = "500W PSU";

public:
    ComputerBuilder& setCPU(const string& c) { cpu = c; return *this; }
    ComputerBuilder& setGPU(const string& g) { gpu = g; return *this; }
    ComputerBuilder& setRAM(int r) { ram = r; return *this; }
    ComputerBuilder& setStorage(int s) { storage = s; return *this; }
    ComputerBuilder& setPowerSupply(const string& psu) { powerSupply = psu; return *this; }

    Computer build() { return Computer(cpu, gpu, ram, storage, powerSupply); }
};

int main() {
    // Create different variants easily
    Computer gamingPC = ComputerBuilder()
        .setCPU("Intel i9")
        .setGPU("RTX 4080")
        .setRAM(32)
        .setStorage(2000)
        .setPowerSupply("850W PSU")
        .build();

    Computer officePC = ComputerBuilder()
        .setCPU("Intel i5")
        .setRAM(16)
        .build();

    cout << "Gaming PC:\n";
    gamingPC.show();

    cout << "\nOffice PC:\n";
    officePC.show();
    return 0;
}
```

---

## ğŸ§  Key Advantages of Builder Pattern

!!! details ""
    | Without Builder          | With Builder                                      |
    | ------------------------ | ------------------------------------------------- |
    | Telescoping constructors | Step-by-step construction                         |
    | Difficult to maintain    | Easy to extend                                    |
    | All params required      | Optional parameters supported                     |
    | Hard to read             | Fluent, readable syntax (`.setCPU().setRAM()...`) |

---

## ğŸ Summary

- The Builder Pattern simplifies object creation by using a fluent interface.
- It promotes immutability and code clarity.
- Ideal for creating complex configurations.

---

## ğŸ”— References
???+ link 
     - [Refactoring.Guru â€“ Builder Pattern](https://refactoring.guru/design-patterns/builder)
     - [SourceMaking â€“ Builder Pattern](https://sourcemaking.com/design_patterns/builder)
     - [GeeksforGeeks â€“ Builder Design Pattern in C++](https://www.geeksforgeeks.org/system-design/builder-design-pattern/)
