# ğŸ­ Factory Design Pattern

## ğŸ§  Introduction

The Factory Design Pattern is a creational design pattern that provides an interface for creating objects, but allows subclasses or separate classes to decide which object to instantiate.
It helps achieve loose coupling by separating the object creation logic from the main business logic.

---

## ğŸ’¡ Real-Life Analogy

Imagine a vehicle manufacturing plant (factory).
Depending on the requirement, the factory can produce:
- ğŸš— Car
- ğŸš² Bike
- ğŸšš Truck

The client doesnâ€™t worry about how the vehicle is made â€” they just ask the factory for one.

---

## ğŸ§© When to Use

Use the Factory Pattern when:
- You need to create objects without exposing the creation logic.
- You have a superclass and want to delegate the instantiation of its subclasses.
- You want to centralize object creation for consistency and control.

---

## ğŸ§± Structure

```mermaid
classDiagram
    Product <|-- ConcreteProductA
    Product <|-- ConcreteProductB
    Creator --> Product

    class Product {
      <<interface>>
      +operation()
    }

    class ConcreteProductA {
      +operation()
    }

    class ConcreteProductB {
      +operation()
    }

    class Creator {
      +createProduct(type): Product
    }
```

---

## âš™ï¸ Implementation Example (C++)
    !!! example ""
    ```cpp title="factory-design.cpp" linenums="1"
    #include <iostream>
    #include <memory>
    #include <string>
    using namespace std;
    
    // Step 1: Create the Product Interface
    class Shape {
    public:
        virtual void draw() = 0;
        virtual ~Shape() = default;
    };
    
    // Step 2: Create Concrete Products
    class Circle : public Shape {
    public:
        void draw() override {
            cout << "Drawing a Circle ğŸŸ¢" << endl;
        }
    };
    
    class Rectangle : public Shape {
    public:
        void draw() override {
            cout << "Drawing a Rectangle ğŸŸ¥" << endl;
        }
    };
    
    class Triangle : public Shape {
    public:
        void draw() override {
            cout << "Drawing a Triangle ğŸ”º" << endl;
        }
    };
    
    // Step 3: Create the Factory
    class ShapeFactory {
    public:
        static shared_ptr<Shape> getShape(const string& shapeType) {
            if (shapeType == "circle")
                return make_shared<Circle>();
            else if (shapeType == "rectangle")
                return make_shared<Rectangle>();
            else if (shapeType == "triangle")
                return make_shared<Triangle>();
            else
                return nullptr;
        }
    };
    
    // Step 4: Demonstrate Usage
    int main() {
        auto circle = ShapeFactory::getShape("circle");
        circle->draw();
    
        auto rectangle = ShapeFactory::getShape("rectangle");
        rectangle->draw();
    
        auto triangle = ShapeFactory::getShape("triangle");
        triangle->draw();
    
        return 0;
    }
    ```
    
---
    
    **ğŸ§® Output**
    ```cpp linenums="1"
    Drawing a Circle ğŸŸ¢
    Drawing a Rectangle ğŸŸ¥
    Drawing a Triangle ğŸ”º
    ```
---

## âœ… Benefits

- Encapsulation: Object creation logic is centralized.
- Loose Coupling: Client code is independent of concrete classes.
- Scalability: Adding a new product type requires minimal change.

## âš ï¸ Drawbacks

- Can introduce complexity when overused.
- Requires modification in factory code to support new products (unless using Abstract Factory or Reflection).

---

##ğŸš€ Real-World Examples

!!! details ""
    | Domain           | Example                                            |
    | ---------------- | -------------------------------------------------- |
    | Database Drivers | JDBC, MongoDB Client Factory                       |
    | GUI Libraries    | Creating buttons, text boxes for Windows/macOS     |
    | Game Engines     | Creating enemy types or weapons dynamically        |
    | Payment Systems  | Different payment processors (UPI, PayPal, Stripe) |

---

## ğŸ§© Types of Factory Patterns

- Simple Factory â†’ A single factory class creates different products.
- Factory Method â†’ Subclasses decide which class to instantiate.
- Abstract Factory â†’ Factory of factories (used for families of related objects).

---

## ğŸ§  Difference Between Factory & Constructor

!!! details ""
    | Factory                            | Constructor              |
    | ---------------------------------- | ------------------------ |
    | Creates objects indirectly         | Creates objects directly |
    | Can decide object type dynamically | Fixed at compile time    |
    | Promotes loose coupling            | Promotes tight coupling  |

---

## ğŸ”— References
???+ link 
     - [Refactoring.Guru â€“ Factory Method](https://refactoring.guru/design-patterns/factory-method)
     - [SourceMaking â€“ Factory Pattern](https://sourcemaking.com/design_patterns/factory_method)
     