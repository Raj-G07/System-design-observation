# üç¥ Clomalo ‚Äì Food Delivery App

## üß© Overview
!!! note ""
    **Clomalo** is a modern food delivery application that enables users to browse nearby restaurants, add food items to their cart, place online orders, and receive real-time notifications about their order status.

---

## ‚öôÔ∏è Functional Requirements

### 1. **Restaurant Search**
- Users can search restaurants by:
  - Location
  - Cuisine type
  - Restaurant name

### 2. **Menu Browsing**
- Display menu with item details (name, price, description, availability).
- Allow filtering and sorting (e.g., vegetarian, spicy, popular).

### 3. **Cart Management**
- Add, update, or remove items.
- Automatically calculate subtotal, tax, and total amount.

### 4. **Checkout & Payment**
- Payment methods:
  - Credit/Debit Card
  - UPI
  - Cash on Delivery (COD)
- Secure payment confirmation.

### 5. **Order Placement**
- Generate a unique **Order ID**.
- Show estimated delivery time.

### 6. **Notifications**
- Notify user on:
  - Order placed successfully
  - Order out for delivery
  - Order delivered

### 7. **User Profile**
- Manage user details and view order history.

---

## üîí Non-Functional Requirements

!!! details ""
    | Category | Description |
    |-----------|-------------|
    | **Scalability** | System should handle peak-hour traffic efficiently. |
    | **Modularity** | Independent services (Search, Cart, Payment). |
    | **Performance** | Search results < 2 seconds, checkout < 3 seconds. |
    | **Security** | SSL, HTTPS, encrypted transactions. |
    | **Reliability** | 99.9% uptime with backup and recovery. |
    | **Usability** | Mobile-first, accessible design. |
    | **Maintainability** | Modular architecture, easy debugging. |

---

## üß† UML Use Case Diagram
!!! info ""
    ```mermaid
    flowchart TD
        User(["üë§ User"])
        Restaurant(["üè™ Restaurant"])
        DeliveryPerson(["üö¥ Delivery Person"])
    
        subgraph "Clomalo Food Delivery System"
            Search[(Search Restaurant)]
            View[(View Menu)]
            Cart[(Add Item to Cart)]
            Payment[(Make Payment)]
            Order[(Place Order)]
            Notify[(Receive Notification)]
            Update[(Update Menu)]
            Accept[(Accept Order)]
            Prepare[(Prepare Food)]
            Pick[(Pick Order)]
            Deliver[(Deliver Order)]
        end
    
        User --> Search --> View --> Cart --> Payment --> Order --> Notify
        Restaurant --> Update --> Accept --> Prepare
        DeliveryPerson --> Pick --> Deliver
    ```

---

## üíª C++ Implementation (Simplified Design)

```cpp title="food-delivery.cpp" linenums="1"
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <thread>
#include <chrono>

using namespace std;

// ---------- ENUMS ----------
enum class OrderStatus {
    PLACED,
    ACCEPTED,
    PREPARING,
    OUT_FOR_DELIVERY,
    DELIVERED
};

// ---------- ENTITY CLASSES ----------

class FoodItem {
    string name;
    double price;
public:
    FoodItem(string n, double p) : name(n), price(p) {}
    string getName() const { return name; }
    double getPrice() const { return price; }
};

class Restaurant {
    string name;
    vector<FoodItem> menu;
public:
    Restaurant(string n, vector<FoodItem> m) : name(n), menu(m) {}

    string getName() const { return name; }
    vector<FoodItem> getMenu() const { return menu; }

    void displayMenu() const {
        cout << "\nüç¥ Menu - " << name << ":\n";
        for (size_t i = 0; i < menu.size(); ++i)
            cout << i + 1 << ". " << menu[i].getName() << " - Rs. " << menu[i].getPrice() << endl;
    }

    void prepareOrder() {
        cout << "\nüë®‚Äçüç≥ " << name << " is preparing your food...\n";
        this_thread::sleep_for(chrono::seconds(2));
        cout << "‚úÖ Food prepared successfully!\n";
    }
};

class Cart {
    vector<FoodItem> items;
public:
    void addItem(const FoodItem& item) {
        items.push_back(item);
        cout << "üõí Added " << item.getName() << " to cart.\n";
    }

    double getTotal() const {
        double total = 0;
        for (const auto& item : items)
            total += item.getPrice();
        return total;
    }

    void showCart() const {
        cout << "\nüõçÔ∏è Cart Items:\n";
        for (const auto& item : items)
            cout << "- " << item.getName() << " : Rs. " << item.getPrice() << endl;
        cout << "Total: Rs. " << getTotal() << "\n";
    }

    vector<FoodItem> getItems() const { return items; }
};

class Payment {
public:
    static bool process(double amount) {
        cout << "\nüí≥ Processing payment of Rs. " << amount << "...\n";
        this_thread::sleep_for(chrono::seconds(1));
        cout << "‚úÖ Payment successful!\n";
        return true;
    }
};

class Order {
    string id;
    OrderStatus status;
    vector<FoodItem> items;
public:
    Order(vector<FoodItem> i) : items(i), status(OrderStatus::PLACED) {
        id = "ORD" + to_string(rand() % 10000 + 1000);
    }

    string getId() const { return id; }
    void updateStatus(OrderStatus s) { status = s; }

    void trackOrder() const {
        cout << "üöö Order Status: ";
        switch (status) {
            case OrderStatus::PLACED: cout << "Placed\n"; break;
            case OrderStatus::ACCEPTED: cout << "Accepted\n"; break;
            case OrderStatus::PREPARING: cout << "Preparing\n"; break;
            case OrderStatus::OUT_FOR_DELIVERY: cout << "Out for delivery\n"; break;
            case OrderStatus::DELIVERED: cout << "Delivered\n"; break;
        }
    }
};

class DeliveryPerson {
    string name;
public:
    DeliveryPerson(string n) : name(n) {}

    void deliverOrder(Order& order) {
        cout << "\nüö¥ " << name << " picked up the order.\n";
        order.updateStatus(OrderStatus::OUT_FOR_DELIVERY);
        order.trackOrder();
        this_thread::sleep_for(chrono::seconds(2));
        order.updateStatus(OrderStatus::DELIVERED);
        cout << "‚úÖ " << name << " delivered your order successfully!\n";
    }
};

class User {
    string name;
    Cart cart;
public:
    User(string n) : name(n) {}

    void searchRestaurant(const vector<Restaurant>& restaurants) {
        cout << "\nüîç Searching restaurants near you...\n";
        for (size_t i = 0; i < restaurants.size(); ++i)
            cout << i + 1 << ". " << restaurants[i].getName() << endl;
    }

    void addToCart(const FoodItem& item) { cart.addItem(item); }

    void checkout(Restaurant& restaurant) {
        cart.showCart();
        double total = cart.getTotal();
        if (Payment::process(total)) {
            Order order(cart.getItems());
            cout << "\nüßæ Order ID: " << order.getId() << " placed successfully!\n";
            order.updateStatus(OrderStatus::ACCEPTED);
            restaurant.prepareOrder();
            order.updateStatus(OrderStatus::PREPARING);
            order.trackOrder();

            DeliveryPerson delivery("Rahul");
            delivery.deliverOrder(order);
        }
    }
};

// ---------- MAIN FUNCTION ----------
int main() {
    srand(time(nullptr));

    // Sample menu
    Restaurant dominoz("Dominoz", {
        FoodItem("Veg Pizza", 250),
        FoodItem("Paneer Roll", 120),
        FoodItem("Garlic Bread", 150)
    });

    vector<Restaurant> restaurants = { dominoz };

    User raj("Raj Gupta");
    raj.searchRestaurant(restaurants);

    // User views menu and adds to cart
    dominoz.displayMenu();
    raj.addToCart(dominoz.getMenu()[0]);
    raj.addToCart(dominoz.getMenu()[2]);

    // Checkout
    raj.checkout(dominoz);

    return 0;
}
```

---

## üßæ Summary

- Core Entities: User, Restaurant, FoodItem, Cart, Payment
- Architecture: Modular & Scalable (can extend with APIs or microservices)
- Diagram: Mermaid-based UML Use Case
- Implementation: Object-Oriented C++
